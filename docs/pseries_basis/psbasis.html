
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>Power Series basis: basic structure and functionality &#8212; Inverse Zeibelger Problem: Power Series basis for Sage 0.4.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/classic.css" />
    
    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Infinite Sequences Framework: working with sequences in SageMath" href="sequences.html" />
    <link rel="prev" title="Inverse Zeibelger Problem" href="../index.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="sequences.html" title="Infinite Sequences Framework: working with sequences in SageMath"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="../index.html" title="Inverse Zeibelger Problem"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">pseries_basis</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Power Series basis: basic structure and functionality</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="module-pseries_basis.psbasis">
<span id="power-series-basis-basic-structure-and-functionality"></span><h1>Power Series basis: basic structure and functionality<a class="headerlink" href="#module-pseries_basis.psbasis" title="Permalink to this headline">¶</a></h1>
<p>Sage package for Power Series Basis.</p>
<p>This module introduces the basic structures in Sage for computing with <em>Power
Series Basis</em>. We based this work in the paper <a class="reference external" href="https://dx.doi.org/10.1016/j.jsc.2022.11.002">doi:10.1016/j.jsc.2022.11.002</a>
by A. Jiménez-Pastor and M. Petkovšek, where all definitions and proofs for the algorithms 
can be found.</p>
<p>In particular, this module allows to consider basis of formal power series subrings, i.e., 
sets of formal power series <span class="math notranslate nohighlight">\(f_n(x) \in \mathbb{K}[[x]]\)</span> that are <span class="math notranslate nohighlight">\(\mathbb{K}\)</span>-linearly 
independent.</p>
<p>There are two easy types of basis:</p>
<ul class="simple">
<li><p>Polynomial basis: here <span class="math notranslate nohighlight">\(f_n \in \mathbb{K}[x]\)</span> with degree equal to <span class="math notranslate nohighlight">\(n\)</span>.</p></li>
<li><p>Order basis: here <span class="math notranslate nohighlight">\(ord(f_n) = n\)</span>, meaning that <span class="math notranslate nohighlight">\(f_n = x^n g_n(x)\)</span> such that <span class="math notranslate nohighlight">\(g(0) \neq 0\)</span>.</p></li>
</ul>
<p>But this module will allow any linearly independent set of functions. Then, we will assume
that a formal power series <span class="math notranslate nohighlight">\(g(x)\)</span> is expressible in terms of the basis <span class="math notranslate nohighlight">\(f_n\)</span>:</p>
<div class="math notranslate nohighlight">
\[g(x) = \sum_{n \in \mathbb{N}} \alpha_n f_n.\]</div>
<p>The main aim of this work is to understand which <span class="math notranslate nohighlight">\(\mathbb{K}\)</span>-linear operators over the
ring of formal power series are <em>compatible</em> with a power series basis, meaning that, 
<span class="math notranslate nohighlight">\(L\cdot g(x) = 0\)</span> if and only if the sequence <span class="math notranslate nohighlight">\(\alpha_n\)</span> is P-recursive.</p>
<p>It is important to remark that this can be analogously develop for basis of sequences
by using the canonical bijection between formal power series and sequences:</p>
<div class="math notranslate nohighlight">
\[\sum_{n} \alpha_n x^n \leftrightarrow (\alpha_n)_n\]</div>
<p>For any given basis, we say that a <span class="math notranslate nohighlight">\(\mathbb{K}\)</span>-linear operator <span class="math notranslate nohighlight">\(L\)</span> is <span class="math notranslate nohighlight">\((A,B)\)</span>-<em>compatible</em>
in <span class="math notranslate nohighlight">\(t\)</span> sections if, for all <span class="math notranslate nohighlight">\(n \in \mathbb{N}\)</span> and <span class="math notranslate nohighlight">\(m \in \{0,\ldots,t-1\}\)</span> we can write:</p>
<p>L f_{nt+m} = sum_{i=-A}^B c_{m,i,n} f_{nt+m+i},</p>
<p>where <span class="math notranslate nohighlight">\((c_{m,i,n})_n\)</span> are <strong>valid</strong> sequences, where <strong>valid</strong> means they are hypergeometric 
in some sense (either <span class="math notranslate nohighlight">\(q\)</span>-hypergeometric or normal hypergeometric). Then, if we have
<span class="math notranslate nohighlight">\(g(x)\)</span> an element in the spanned space by our basis with</p>
<p>g = sum_k alpha_k f_k, qquad L cdot g = 0,</p>
<p>then the sequence <span class="math notranslate nohighlight">\((\alpha_k)_k\)</span> satisfy a set of recurrences inherited from the compatibility
equation of <span class="math notranslate nohighlight">\(L\)</span> for the basis.</p>
<p>EXAMPLES:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sage</span><span class="p">:</span> <span class="kn">from</span> <span class="nn">pseries_basis</span> <span class="kn">import</span> <span class="o">*</span>
<span class="n">sage</span><span class="p">:</span> <span class="kn">from</span> <span class="nn">pseries_basis.sequences</span> <span class="kn">import</span> <span class="o">*</span>
<span class="n">sage</span><span class="p">:</span> <span class="n">B</span> <span class="o">=</span> <span class="n">PSBasis</span><span class="p">(</span><span class="k">lambda</span> <span class="n">k</span> <span class="p">:</span> <span class="n">RationalSequence</span><span class="p">(</span><span class="n">QQ</span><span class="p">[</span><span class="n">x</span><span class="p">](</span><span class="n">x</span><span class="o">**</span><span class="n">k</span><span class="p">)),</span> <span class="n">QQ</span><span class="p">)</span> <span class="c1"># B_k(x) = x^k</span>
<span class="n">sage</span><span class="p">:</span> <span class="n">B</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">Sequence</span> <span class="n">over</span> <span class="p">[</span><span class="n">Rational</span> <span class="n">Field</span><span class="p">]:</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span><span class="o">...</span><span class="p">)</span>
<span class="n">sage</span><span class="p">:</span> <span class="n">B</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="n">Sequence</span> <span class="n">over</span> <span class="p">[</span><span class="n">Rational</span> <span class="n">Field</span><span class="p">]:</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span><span class="o">...</span><span class="p">)</span>
<span class="n">sage</span><span class="p">:</span> <span class="n">B</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
<span class="n">Sequence</span> <span class="n">over</span> <span class="p">[</span><span class="n">Rational</span> <span class="n">Field</span><span class="p">]:</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span><span class="o">...</span><span class="p">)</span>
<span class="n">sage</span><span class="p">:</span> <span class="n">B</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span><span class="o">.</span><span class="n">generic</span><span class="p">()</span>
<span class="n">x</span><span class="o">^</span><span class="mi">10</span>
</pre></div>
</div>
<p>We can from this point set up the compatibilities for this basis:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sage</span><span class="p">:</span> <span class="n">B</span><span class="o">.</span><span class="n">set_compatibility</span><span class="p">(</span>
<span class="o">....</span><span class="p">:</span>     <span class="s1">&#39;x&#39;</span><span class="p">,</span> 
<span class="o">....</span><span class="p">:</span>     <span class="n">Compatibility</span><span class="p">([[</span><span class="n">ConstantSequence</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">QQ</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="n">ConstantSequence</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">QQ</span><span class="p">,</span><span class="mi">1</span><span class="p">)]],</span> <span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> 
<span class="o">....</span><span class="p">:</span>     <span class="nb">type</span><span class="o">=</span><span class="s2">&quot;any&quot;</span>
<span class="o">....</span><span class="p">:</span> <span class="p">)</span> <span class="c1"># compatibility with x</span>
<span class="n">Compatibility</span> <span class="n">condition</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="k">with</span> <span class="n">following</span> <span class="n">coefficient</span> <span class="n">matrix</span><span class="p">:</span>
<span class="p">[</span><span class="mi">0</span> <span class="mi">1</span><span class="p">]</span>
<span class="n">sage</span><span class="p">:</span> <span class="n">B</span><span class="o">.</span><span class="n">set_compatibility</span><span class="p">(</span>
<span class="o">....</span><span class="p">:</span>     <span class="s1">&#39;Dx&#39;</span><span class="p">,</span> 
<span class="o">....</span><span class="p">:</span>     <span class="n">Compatibility</span><span class="p">([[</span><span class="n">RationalSequence</span><span class="p">(</span><span class="n">QQ</span><span class="p">[</span><span class="s1">&#39;n&#39;</span><span class="p">](</span><span class="s1">&#39;n&#39;</span><span class="p">)),</span> <span class="n">ConstantSequence</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">QQ</span><span class="p">,</span><span class="mi">1</span><span class="p">)]],</span> <span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> 
<span class="o">....</span><span class="p">:</span>     <span class="nb">type</span><span class="o">=</span><span class="s2">&quot;derivation&quot;</span>
<span class="o">....</span><span class="p">:</span> <span class="p">)</span> <span class="c1"># compatibility with Dx</span>
<span class="n">Compatibility</span> <span class="n">condition</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="k">with</span> <span class="n">following</span> <span class="n">coefficient</span> <span class="n">matrix</span><span class="p">:</span>
<span class="p">[</span><span class="n">n</span> <span class="mi">0</span><span class="p">]</span>
</pre></div>
</div>
<p>And then the compatibility conditions can be obtained for any expression involving objects called <span class="math notranslate nohighlight">\(x\)</span>
and <span class="math notranslate nohighlight">\(Dx\)</span>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sage</span><span class="p">:</span> <span class="n">B</span><span class="o">.</span><span class="n">is_compatible</span><span class="p">(</span><span class="s2">&quot;x**2 * Dx**2 - Dx + x^3&quot;</span><span class="p">)</span>
<span class="kc">True</span>
<span class="n">sage</span><span class="p">:</span> <span class="n">B</span><span class="o">.</span><span class="n">compatibility_type</span><span class="p">(</span><span class="s2">&quot;x**2 * Dx**2 - Dx + x^3&quot;</span><span class="p">)</span>
<span class="s1">&#39;derivation&#39;</span>
</pre></div>
</div>
<dl class="py class">
<dt class="sig sig-object py" id="pseries_basis.psbasis.PSBasis">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pseries_basis.psbasis.</span></span><span class="sig-name descname"><span class="pre">PSBasis</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sequence</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">universe</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">_extend_by_zero</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwds</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pseries_basis.psbasis.PSBasis" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="sequences/base.html#pseries_basis.sequences.base.Sequence" title="pseries_basis.sequences.base.Sequence"><code class="xref py py-class docutils literal notranslate"><span class="pre">pseries_basis.sequences.base.Sequence</span></code></a></p>
<p>Base class for a basis of formal power series/sequences.</p>
<p>This class allows to represent any basis of formal power series of sequences over a 
SageMath field <span class="math notranslate nohighlight">\(\mathbb{K}\)</span>. In general, a basis is a sequence <span class="math notranslate nohighlight">\(f_k\)</span> indexed by
an natural number <span class="math notranslate nohighlight">\(k\)</span> of formal power series or sequences. Hence, this class
inherits from the generic sequence class in <a class="reference internal" href="sequences/base.html#pseries_basis.sequences.base.Sequence" title="pseries_basis.sequences.base.Sequence"><code class="xref py py-class docutils literal notranslate"><span class="pre">Sequence</span></code></a>,
and always provides a representation as a sequence of sequences.</p>
<div class="math notranslate nohighlight">
\[`\mathcal{B}: k \mapsto (\alpha_{k,n})_n`\]</div>
<p>where <span class="math notranslate nohighlight">\(f_k(x) = \sum_n \alpha_{k,n}x^n\)</span>.</p>
<p>This class will implement any other method for basis of formal power series related with
the compatibility of a sequence.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pseries_basis.psbasis.PSBasis.args_to_self">
<span class="sig-name descname"><span class="pre">args_to_self</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pseries_basis.psbasis.PSBasis.args_to_self" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pseries_basis.psbasis.PSBasis.as_2dim">
<span class="sig-name descname"><span class="pre">as_2dim</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pseries_basis.psbasis.PSBasis.as_2dim" title="Permalink to this definition">¶</a></dt>
<dd><p>EXAMPLES:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sage</span><span class="p">:</span> <span class="k">class</span> <span class="nc">Foo</span><span class="p">:</span>
<span class="o">....</span><span class="p">:</span>     <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
<span class="o">....</span><span class="p">:</span>         <span class="bp">self</span><span class="o">.</span><span class="n">_x</span> <span class="o">=</span> <span class="n">x</span>
<span class="o">....</span><span class="p">:</span>     <span class="nd">@cached_method</span>
<span class="o">....</span><span class="p">:</span>     <span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="o">....</span><span class="p">:</span>         <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_x</span><span class="o">^</span><span class="mi">2</span>
<span class="n">sage</span><span class="p">:</span> <span class="n">a</span> <span class="o">=</span> <span class="n">Foo</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">sage</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">f</span><span class="o">.</span><span class="n">cache</span><span class="p">)</span>
<span class="kc">None</span>
<span class="n">sage</span><span class="p">:</span> <span class="n">a</span><span class="o">.</span><span class="n">f</span><span class="p">()</span>
<span class="mi">4</span>
<span class="n">sage</span><span class="p">:</span> <span class="n">a</span><span class="o">.</span><span class="n">f</span><span class="o">.</span><span class="n">cache</span>
<span class="mi">4</span>
</pre></div>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pseries_basis.psbasis.PSBasis.base">
<span class="sig-name descname"><span class="pre">base</span></span><a class="headerlink" href="#pseries_basis.psbasis.PSBasis.base" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pseries_basis.psbasis.PSBasis.basic_compatibilities">
<span class="sig-name descname"><span class="pre">basic_compatibilities</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pseries_basis.psbasis.PSBasis.basic_compatibilities" title="Permalink to this definition">¶</a></dt>
<dd><p>Method that return a copy of the current basic compatibilities that exist for <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>See method <a class="reference internal" href="#pseries_basis.psbasis.PSBasis.compatibility" title="pseries_basis.psbasis.PSBasis.compatibility"><code class="xref py py-func docutils literal notranslate"><span class="pre">compatibility()</span></code></a> for further information.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pseries_basis.psbasis.PSBasis.change_base">
<span class="sig-name descname"><span class="pre">change_base</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">base</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pseries_basis.psbasis.PSBasis.change_base" title="Permalink to this definition">¶</a></dt>
<dd><p>Method to compute the same basis of sequences as <code class="docutils literal notranslate"><span class="pre">self</span></code> with a different base ring.</p>
<p>This method creates a new <a class="reference internal" href="#pseries_basis.psbasis.PSBasis" title="pseries_basis.psbasis.PSBasis"><code class="xref py py-class docutils literal notranslate"><span class="pre">PSBasis</span></code></a> that changes the ring over which the elements
are defined. This method does not guarantee the new basis makes real sense and it
may raise some errors when creating the elements of the basis.</p>
<p><strong>Overriding recommended</strong>: this method acts as a default way of changing the base
ring of a <a class="reference internal" href="#pseries_basis.psbasis.PSBasis" title="pseries_basis.psbasis.PSBasis"><code class="xref py py-class docutils literal notranslate"><span class="pre">PSBasis</span></code></a> but it may lose some information in the process. In order
to preserve the structure of the <a class="reference internal" href="#pseries_basis.psbasis.PSBasis" title="pseries_basis.psbasis.PSBasis"><code class="xref py py-class docutils literal notranslate"><span class="pre">PSBasis</span></code></a>, this method should be overridden.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">base</span></code>: a new parent structure for the universe of the elements of <code class="docutils literal notranslate"><span class="pre">self</span></code></p></li>
</ul>
<p>OUTPUT:</p>
<p>A equivalent basis where the elements have as common universe <code class="docutils literal notranslate"><span class="pre">base</span></code></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pseries_basis.psbasis.PSBasis.compatibility">
<span class="sig-name descname"><span class="pre">compatibility</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">operator</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pseries_basis.psbasis.PSBasis.compatibility" title="Permalink to this definition">¶</a></dt>
<dd><p>Method that returns the compatibility of a given operator with <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>Check documentation of <a class="reference internal" href="#pseries_basis.psbasis.Compatibility" title="pseries_basis.psbasis.Compatibility"><code class="xref py py-class docutils literal notranslate"><span class="pre">Compatibility</span></code></a> for further information on
what a compatible operator is.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">operator</span></code>: the operator that we want to compute the compatibility. It
can be any object that can be casted into a free algebra over the names
that are currently compatible with <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p></li>
</ul>
<p>OUTPUT:</p>
<p>A <a class="reference internal" href="#pseries_basis.psbasis.Compatibility" title="pseries_basis.psbasis.Compatibility"><code class="xref py py-class docutils literal notranslate"><span class="pre">Compatibility</span></code></a> condition for the operator. It raises en error when 
it is not possible to cast the operator to a compatible operator.</p>
<p>INFORMATION:</p>
<p>This method is cached.</p>
<p>TODO: add examples</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pseries_basis.psbasis.PSBasis.compatibility_type">
<span class="sig-name descname"><span class="pre">compatibility_type</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">operator</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pseries_basis.psbasis.PSBasis.compatibility_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Method to determine if an operator belong to a specific type.</p>
<p>Operators may have three different types:</p>
<ul class="simple">
<li><p>“homomorphism”: it behaves nicely with the product.</p></li>
<li><p>“derivation”: it satisfies the Leibniz rule for the product.</p></li>
<li><p>“any”: an operator that can be combined for any of the two previous.</p></li>
</ul>
<p>It may also have type “None”, meaning we could not deduce any specific behavior.</p>
<p>This methods behaves similar to the methods <a class="reference internal" href="#pseries_basis.psbasis.PSBasis.compatibility" title="pseries_basis.psbasis.PSBasis.compatibility"><code class="xref py py-func docutils literal notranslate"><span class="pre">compatibility()</span></code></a> and 
<a class="reference internal" href="#pseries_basis.psbasis.PSBasis.is_compatible" title="pseries_basis.psbasis.PSBasis.is_compatible"><code class="xref py py-func docutils literal notranslate"><span class="pre">is_compatible()</span></code></a> but, contrary to method <a class="reference internal" href="#pseries_basis.psbasis.PSBasis.compatibility" title="pseries_basis.psbasis.PSBasis.compatibility"><code class="xref py py-func docutils literal notranslate"><span class="pre">compatibility()</span></code></a>,
this method do <strong>not</strong> compute the actual compatibility.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">operator</span></code>: the object that we want to check.</p></li>
</ul>
<p>INFORMATION:</p>
<p>This method is cached.</p>
<p>OUTPUT:</p>
<p>Either a string in (“homomorphism”, “derivation”, “any”) or None.</p>
<p>TODO: add examples</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pseries_basis.psbasis.PSBasis.compatible_derivations">
<span class="sig-name descname"><span class="pre">compatible_derivations</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pseries_basis.psbasis.PSBasis.compatible_derivations" title="Permalink to this definition">¶</a></dt>
<dd><p>Method that return a copy of the current compatible derivations that exist for <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>See method <a class="reference internal" href="#pseries_basis.psbasis.PSBasis.compatibility" title="pseries_basis.psbasis.PSBasis.compatibility"><code class="xref py py-func docutils literal notranslate"><span class="pre">compatibility()</span></code></a> for further information.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pseries_basis.psbasis.PSBasis.compatible_endomorphisms">
<span class="sig-name descname"><span class="pre">compatible_endomorphisms</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pseries_basis.psbasis.PSBasis.compatible_endomorphisms" title="Permalink to this definition">¶</a></dt>
<dd><p>Method that return a copy of the current compatible homomorphisms that exist for <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>See method <a class="reference internal" href="#pseries_basis.psbasis.PSBasis.compatibility" title="pseries_basis.psbasis.PSBasis.compatibility"><code class="xref py py-func docutils literal notranslate"><span class="pre">compatibility()</span></code></a> for further information.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pseries_basis.psbasis.PSBasis.double_algebra">
<span class="sig-name descname"><span class="pre">double_algebra</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pseries_basis.psbasis.PSBasis.double_algebra" title="Permalink to this definition">¶</a></dt>
<dd><p>Method to get the ore algebra for recurrences with inverses</p>
<p>This method builds the corresponding Ore Algebra that can will appear in the 
recurrences that are derived from compatibility conditions.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pseries_basis.psbasis.PSBasis.double_gens">
<span class="sig-name descname"><span class="pre">double_gens</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pseries_basis.psbasis.PSBasis.double_gens" title="Permalink to this definition">¶</a></dt>
<dd><p>Method that returns the shifts of the double-shift algebra</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pseries_basis.psbasis.PSBasis.double_var">
<span class="sig-name descname"><span class="pre">double_var</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pseries_basis.psbasis.PSBasis.double_var" title="Permalink to this definition">¶</a></dt>
<dd><p>Method that returns the variable affected by the shift in the double-shift algebra</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pseries_basis.psbasis.PSBasis.generic">
<span class="sig-name descname"><span class="pre">generic</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">names</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pseries_basis.psbasis.PSBasis.generic" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pseries_basis.psbasis.PSBasis.inner_init_values">
<span class="sig-name descname"><span class="pre">inner_init_values</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sum_sequence</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">desired_values</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inner_recurrence</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">full</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">section</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shift</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pseries_basis.psbasis.PSBasis.inner_init_values" title="Permalink to this definition">¶</a></dt>
<dd><p>Method to obtain the initial values of an inner sequence using this basis.</p>
<p>Let <span class="math notranslate nohighlight">\((a_n)_n\)</span> be a sequence, and assume that we know that</p>
<div class="math notranslate nohighlight">
\[a_n = \sum_{k\geq 0} c_k B_k(n).\]</div>
<p>We say that <span class="math notranslate nohighlight">\((c_k)_k\)</span> is the <em>inner sequence of `(a_n)_n` wrt `B_k(n)`</em>. This method takes the sequence
<span class="math notranslate nohighlight">\((a_n)_n\)</span>, the number of elements of <span class="math notranslate nohighlight">\(c_k\)</span> we want to compute and (optionally) a recurrence for the 
sequence <span class="math notranslate nohighlight">\(c_k\)</span>.</p>
<p>If this recurrence for <span class="math notranslate nohighlight">\((c_k)_k\)</span> is not provided, we can only compute this for triangular sequences (i.e., 
the quasi-triangular sequence given by <a class="reference internal" href="#pseries_basis.psbasis.PSBasis.is_quasi_triangular" title="pseries_basis.psbasis.PSBasis.is_quasi_triangular"><code class="xref py py-func docutils literal notranslate"><span class="pre">is_quasi_triangular()</span></code></a> is the identity sequence).</p>
<p>Otherwise, we can obtain an unrolling matrix <span class="math notranslate nohighlight">\(\Lambda_T = (\alpha_{i,k}) \in \mathbb{K}^{r\times T}\)</span> such that
<span class="math notranslate nohighlight">\((c_0,\ldots, c_{T-1}) = (c_0,\ldots, c_{r-1}) \Lambda_T\)</span> where <span class="math notranslate nohighlight">\(r\)</span> is the order of the <code class="docutils literal notranslate"><span class="pre">inner_recurrence</span></code>. Then,
we can compute for any <span class="math notranslate nohighlight">\(T\)</span> the product of matrices <span class="math notranslate nohighlight">\(\Lambda_T B_{T,N}\)</span> where the matrix <span class="math notranslate nohighlight">\(B_{T,N}\)</span> is the output
of <a class="reference internal" href="#pseries_basis.psbasis.basis_matrix" title="pseries_basis.psbasis.basis_matrix"><code class="xref py py-func docutils literal notranslate"><span class="pre">basis_matrix()</span></code></a> over <code class="docutils literal notranslate"><span class="pre">self</span></code> for <span class="math notranslate nohighlight">\(T\)</span> rows and <span class="math notranslate nohighlight">\(N\)</span> columns.</p>
<p>Moreover, if <span class="math notranslate nohighlight">\(T \geq i_N\)</span>, then</p>
<div class="math notranslate nohighlight">
\[\]</div>
<p>(a_0,ldots, a_{N-1}) = (c_0,ldots, c_{r-1}) left(Lambda_T B_{T,N}right).</p>
<p>If the matrix <span class="math notranslate nohighlight">\(\left(\Lambda_T B_{T,N}\right)\)</span> has rank <span class="math notranslate nohighlight">\(r\)</span>, then there is a pseudo-inverse matrix <span class="math notranslate nohighlight">\(A^+\)</span> such that</p>
<div class="math notranslate nohighlight">
\[\]</div>
<p>(c_0, ldots, c_{r-1}) = (a_0,ldots, a_{N-1}) A^+.</p>
<p>Then, from this position, we can compute the required terms of <span class="math notranslate nohighlight">\((c_k)_k\)</span>. Otherwise, for each <span class="math notranslate nohighlight">\(N\)</span>, we can compute the 
<span class="math notranslate nohighlight">\(i_N\)</span> of the quasi-triangular sequence and obtain a space of possible solutions for <span class="math notranslate nohighlight">\((c_0,\ldots,c_{r-1})\)</span>, denote it by <span class="math notranslate nohighlight">\(S_N\)</span>.
If there is a solution, then <span class="math notranslate nohighlight">\(\bigcap_N S_N\)</span> has to stabilize. This intersection is still an affine space and any element
in it will be a valid solution to this function.</p>
<p>If this intersection does not stabilize, then we conclude there is no solution.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">sum_sequence</span></code>: the <code class="xref py py-class docutils literal notranslate"><span class="pre">Sequence</span></code> for the <span class="math notranslate nohighlight">\((a_n)_n\)</span>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">desired_values</span></code>: number of elements of the inner sequence we are aiming to compute.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">inner_recurrence</span></code> (optional): recurrence for the inner sequence.</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pseries_basis.psbasis.PSBasis.is_compatible">
<span class="sig-name descname"><span class="pre">is_compatible</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">operator</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pseries_basis.psbasis.PSBasis.is_compatible" title="Permalink to this definition">¶</a></dt>
<dd><p>Method that checks whether an object is compatible with a <a class="reference internal" href="#pseries_basis.psbasis.PSBasis" title="pseries_basis.psbasis.PSBasis"><code class="xref py py-class docutils literal notranslate"><span class="pre">PSBasis</span></code></a>.</p>
<p>This method tries to create the free algebra of compatible operators and cast
the object <code class="docutils literal notranslate"><span class="pre">operator</span></code> to this ring. This is also done in the method 
<a class="reference internal" href="#pseries_basis.psbasis.PSBasis.compatibility" title="pseries_basis.psbasis.PSBasis.compatibility"><code class="xref py py-func docutils literal notranslate"><span class="pre">compatibility()</span></code></a>. The main difference is that this method do <strong>not</strong>
compute the actual compatibility.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">operator</span></code>: an object to be checked for compatibility.</p></li>
</ul>
<p>INFORMATION:</p>
<p>This method is cached.</p>
<p>OUTPUT:</p>
<p>A boolean value indicating if the method <a class="reference internal" href="#pseries_basis.psbasis.PSBasis.compatibility" title="pseries_basis.psbasis.PSBasis.compatibility"><code class="xref py py-func docutils literal notranslate"><span class="pre">compatibility()</span></code></a> will
return something or an error.</p>
<p>TODO: add examples</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pseries_basis.psbasis.PSBasis.is_quasi_triangular">
<span class="sig-name descname"><span class="pre">is_quasi_triangular</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pseries_basis.psbasis.PSBasis.is_quasi_triangular" title="Permalink to this definition">¶</a></dt>
<dd><p>Method to check whether a basis is quasi-triangular or not.</p>
<p>We say that <span class="math notranslate nohighlight">\(\{B_k(n)\}_k\)</span> is quasi-triangular if there is a sequence <span class="math notranslate nohighlight">\((i_n)_n\)</span> such that:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(B_{i_n}(n) \neq 0\)</span>.</p></li>
<li><p><span class="math notranslate nohighlight">\(B_k(n) = 0\)</span> for all <span class="math notranslate nohighlight">\(k &gt; i_n\)</span>.</p></li>
<li><p><span class="math notranslate nohighlight">\(i_{n+1} &gt; i_n\)</span>.</p></li>
</ul>
<p>If the sequences <span class="math notranslate nohighlight">\(B_k(n)\)</span> define formal power series <span class="math notranslate nohighlight">\(f_k(x) = \sum_{n&gt;0} B_k(n)x^n\)</span>, then
this is equivalent to <span class="math notranslate nohighlight">\(x^{i_n} | f_k(n)\)</span> if <span class="math notranslate nohighlight">\(k &gt; i_n\)</span> and <span class="math notranslate nohighlight">\(x^{i_n} \nmid f_{i_n}(x)\)</span>.</p>
<p>This method returns <code class="docutils literal notranslate"><span class="pre">None</span></code> if we do not know if the basis is quasi-triangular and the sequence
<span class="math notranslate nohighlight">\(i_n\)</span>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pseries_basis.psbasis.PSBasis.ore_algebra">
<span class="sig-name descname"><span class="pre">ore_algebra</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pseries_basis.psbasis.PSBasis.ore_algebra" title="Permalink to this definition">¶</a></dt>
<dd><p>Method to get the ore algebra for recurrences</p>
<p>This method builds the corresponding Ore Algebra that can will appear in the 
recurrences that are derived from compatibility conditions.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pseries_basis.psbasis.PSBasis.ore_gen">
<span class="sig-name descname"><span class="pre">ore_gen</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pseries_basis.psbasis.PSBasis.ore_gen" title="Permalink to this definition">¶</a></dt>
<dd><p>Method that returns the shift of the shift algebra</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pseries_basis.psbasis.PSBasis.ore_var">
<span class="sig-name descname"><span class="pre">ore_var</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pseries_basis.psbasis.PSBasis.ore_var" title="Permalink to this definition">¶</a></dt>
<dd><p>Method that returns the variable affected by the shift in the shift algebra</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pseries_basis.psbasis.PSBasis.recurrence">
<span class="sig-name descname"><span class="pre">recurrence</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">operator</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sections</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">output</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'ore_double'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pseries_basis.psbasis.PSBasis.recurrence" title="Permalink to this definition">¶</a></dt>
<dd><p>Method to obtain a recurrence for a compatible operator.</p>
<p>Following the theory in <a class="reference external" href="https://dx.doi.org/10.1016/j.jsc.2022.11.002">doi:10.1016/j.jsc.2022.11.002</a>, when we have an 
operator <span class="math notranslate nohighlight">\(L\)</span> that is <span class="math notranslate nohighlight">\((A,B,t)\)</span>-compatible with a basis os sequences such that</p>
<div class="math notranslate nohighlight">
\[L P_{kt+b} = \sum_{i=-A}^B c_{b,i}(k) P_{kt+b+i},\]</div>
<p>then the solutions <span class="math notranslate nohighlight">\(L\cdot (\sum_k a_kP_k) = 0\)</span> can be obtained from solutions to
<span class="math notranslate nohighlight">\(\tilde{L} \cdot a_k\)</span> where <span class="math notranslate nohighlight">\(\tilde{L}\)</span> can be automatically computed from 
the compatibility and the coefficients <span class="math notranslate nohighlight">\(c_{b,i}(k)\)</span>.</p>
<p>This method creates such recurrence (or system of recurrences) given the compatible 
operator.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">operator</span></code>: an object that will be fed to method <a class="reference internal" href="#pseries_basis.psbasis.PSBasis.compatibility" title="pseries_basis.psbasis.PSBasis.compatibility"><code class="xref py py-func docutils literal notranslate"><span class="pre">compatibility()</span></code></a>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">sections</span></code>: indicate the number of sections that will be considered for the 
compatibility condition. If has to be a multiple of the default number of 
sections for the <code class="docutils literal notranslate"><span class="pre">operator</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">output</span></code>: by default the output of this method is a Laurent Polynomial in 
a shift operator with sequences as coefficients. This argument indicates 
where we should transform this output to be used later. It allow two options:</p>
<ul>
<li><p>“rational”: force the sequence in the output to be rational sequences.</p></li>
<li><p>“expression”: force the sequence in the output to be an expression sequence.</p></li>
<li><p>“ore_double”: a Ore Algebra with two operators will be used as output.
This requires the sequences are rational functions in the shift variable 
and the two operators on the algebra will act as the forward and backward 
shift.</p></li>
<li><p>“ore”: a Ore Algebra with just a shift will be used as output. Similar to the
double case, but we remove completely the inverse shift.</p></li>
</ul>
</li>
</ul>
<p>OUTPUT:</p>
<p>A recurrence or a matrix of recurrences as described in <a class="reference external" href="https://dx.doi.org/10.1016/j.jsc.2022.11.002">doi:10.1016/j.jsc.2022.11.002</a>.</p>
<p>TODO: add examples.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pseries_basis.psbasis.PSBasis.scalar">
<span class="sig-name descname"><span class="pre">scalar</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">factor</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pseries_basis.psbasis.PSBasis.scalar" title="Permalink to this definition">¶</a></dt>
<dd><p>Method to scale a <a class="reference internal" href="#pseries_basis.psbasis.PSBasis" title="pseries_basis.psbasis.PSBasis"><code class="xref py py-class docutils literal notranslate"><span class="pre">PSBasis</span></code></a> preserving compatibilities.</p>
<p>This method computes a new <a class="reference internal" href="#pseries_basis.psbasis.PSBasis" title="pseries_basis.psbasis.PSBasis"><code class="xref py py-class docutils literal notranslate"><span class="pre">PSBasis</span></code></a> structure and extends
when possible the compatibility conditions over <code class="docutils literal notranslate"><span class="pre">self</span></code>. The elements
of the new sequence is the scaling by the sequence given in <code class="docutils literal notranslate"><span class="pre">factor</span></code>.</p>
<p>This method works on two steps:</p>
<ul class="simple">
<li><p>First, we create a new <a class="reference internal" href="#pseries_basis.psbasis.PSBasis" title="pseries_basis.psbasis.PSBasis"><code class="xref py py-class docutils literal notranslate"><span class="pre">PSBasis</span></code></a> with the corresponding elements.
This may differ from different classes and can be extended in the method
<code class="xref py py-func docutils literal notranslate"><span class="pre">_scalar_basis()</span></code>.</p></li>
<li><p>Second, we extend the compatibilities. Since some of the compatibilities
can be automatically computed when creating the basis, we only extends those
compatibilities that are not already created.</p></li>
</ul>
<p>This method exploits when possible the fact that the given factor is hypergeometric.
This is based in the method <code class="xref py py-func docutils literal notranslate"><span class="pre">sequences.base.Sequence.is_hypergeometric()</span></code>. If this 
method succeeds, we use the rational function obtained to extend compatibilities.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">factor</span></code>: a <a class="reference internal" href="sequences/base.html#pseries_basis.sequences.base.Sequence" title="pseries_basis.sequences.base.Sequence"><code class="xref py py-class docutils literal notranslate"><span class="pre">sequences.base.Sequence</span></code></a> with the scaling factor.</p></li>
</ul>
<p>OUTPUT:</p>
<p>A new basis with the extended compatibilities.</p>
<p><strong>WARNING</strong>:</p>
<p>This method assumes that the sequence given by <code class="docutils literal notranslate"><span class="pre">factor</span></code> never vanishes.</p>
<p>TODO: add examples.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pseries_basis.psbasis.PSBasis.set_compatibility">
<span class="sig-name descname"><span class="pre">set_compatibility</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">compatibility</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sub</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pseries_basis.psbasis.PSBasis.set_compatibility" title="Permalink to this definition">¶</a></dt>
<dd><p>Method to set a new compatibility with this <a class="reference internal" href="#pseries_basis.psbasis.PSBasis" title="pseries_basis.psbasis.PSBasis"><code class="xref py py-class docutils literal notranslate"><span class="pre">PSBasis</span></code></a>.</p>
<p>This method receives a name for the operator whose compatibility will be set and a 
compatibility condition for this operator. This method does not check whether 
this compatibility is real or not and this job is left to the user.</p>
<p>In general, this method is not <em>recommended</em> for users.</p>
<p>The compatibility condition can be given in 3 different ways:</p>
<ul class="simple">
<li><p>A <a class="reference internal" href="#pseries_basis.psbasis.Compatibility" title="pseries_basis.psbasis.Compatibility"><code class="xref py py-class docutils literal notranslate"><span class="pre">Compatibility</span></code></a> object: it is directly stored</p></li>
<li><p>A tuple <span class="math notranslate nohighlight">\((A,B,\alpha)\)</span> or <span class="math notranslate nohighlight">\((A,B,m,\alpha)\)</span>: we create a <a class="reference internal" href="#pseries_basis.psbasis.Compatibility" title="pseries_basis.psbasis.Compatibility"><code class="xref py py-class docutils literal notranslate"><span class="pre">Compatibility</span></code></a>
using directly this data.</p></li>
<li><p>An ore operator in a ring with one shift where we can read the data
to create a <a class="reference internal" href="#pseries_basis.psbasis.Compatibility" title="pseries_basis.psbasis.Compatibility"><code class="xref py py-class docutils literal notranslate"><span class="pre">Compatibility</span></code></a> right from it.</p></li>
</ul>
<p>If the argument <code class="docutils literal notranslate"><span class="pre">sub</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code>, we substitute the compatibility, if not, 
we raise a <code class="xref py py-class docutils literal notranslate"><span class="pre">ValueError</span></code>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">name</span></code>: the name of the operator that we are defining as compatible.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">compatibility</span></code>: the compatibility condition to be set.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">sub</span></code>: if set to <code class="docutils literal notranslate"><span class="pre">True</span></code>, we substitute the old compatibility with the new.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">type</span></code>: a string (or None) describing the type of the operator. It can be <code class="docutils literal notranslate"><span class="pre">&quot;homomorphism&quot;</span></code>
or <code class="docutils literal notranslate"><span class="pre">&quot;derivation&quot;</span></code>.</p></li>
</ul>
<p>OUTPUT:</p>
<p>It will return the created compatibility condition in case of success or an error
if something goes wrong.</p>
<p>TODO: add examples</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pseries_basis.psbasis.PSBasis.set_derivation">
<span class="sig-name descname"><span class="pre">set_derivation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">compatibility</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sub</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pseries_basis.psbasis.PSBasis.set_derivation" title="Permalink to this definition">¶</a></dt>
<dd><p>See <a class="reference internal" href="#pseries_basis.psbasis.PSBasis.set_compatibility" title="pseries_basis.psbasis.PSBasis.set_compatibility"><code class="xref py py-func docutils literal notranslate"><span class="pre">set_compatibility()</span></code></a>. This method adds a compatibility for a derivation</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pseries_basis.psbasis.PSBasis.set_homomorphism">
<span class="sig-name descname"><span class="pre">set_homomorphism</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">compatibility</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sub</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pseries_basis.psbasis.PSBasis.set_homomorphism" title="Permalink to this definition">¶</a></dt>
<dd><p>See <a class="reference internal" href="#pseries_basis.psbasis.PSBasis.set_compatibility" title="pseries_basis.psbasis.PSBasis.set_compatibility"><code class="xref py py-func docutils literal notranslate"><span class="pre">set_compatibility()</span></code></a>. This method adds a compatibility for an homomorphism</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pseries_basis.psbasis.Compatibility">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pseries_basis.psbasis.</span></span><span class="sig-name descname"><span class="pre">Compatibility</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">c</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">A</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">B</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pseries_basis.psbasis.Compatibility" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Class representing a compatibility condition in sections.</p>
<p>A compatibility condition is associated to a basis of power series and with a linear operator
that behaves <em>nicely</em> with the basis. More precisely, if we consider the basis <span class="math notranslate nohighlight">\((f_k)_k\)</span> and 
the linear operator <span class="math notranslate nohighlight">\(L\)</span>, we say that <span class="math notranslate nohighlight">\(L\)</span> is <span class="math notranslate nohighlight">\((A,B)\)</span>-<em>compatible</em> in <span class="math notranslate nohighlight">\(t\)</span> sections with the basis if, for all 
<span class="math notranslate nohighlight">\(a \in \mathbb{N}\)</span> and <span class="math notranslate nohighlight">\(b \in \{0,\ldots,t-1}\)</span>:</p>
<div class="math notranslate nohighlight">
\[L f_{at+b} = \sum_{i=-A}^B c_{b,i,a} f_{at+b+i},\]</div>
<p>where, for fixed indices <span class="math notranslate nohighlight">\(b,i\)</span>, the element <span class="math notranslate nohighlight">\((c_{b,i,a})_a\)</span> are <em>nice sequences</em>. In general, the niceness of the 
sequences <span class="math notranslate nohighlight">\((c_{b,i,a})\)</span> required depends on the operations we pretend to apply over the compatibility.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">c</span></code>: coefficients of the compatibility. It must be an object that should be accessed with syntax <span class="math notranslate nohighlight">\(c[b][i]\)</span>. 
These objects must be sequences.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">A</span></code>: lower bound of the compatibility.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">B</span></code>: upper bound of the compatibility.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">t</span></code>: number of sections for the compatibility.</p></li>
</ul>
<p>The input can be given partially or totally. The coefficients <span class="math notranslate nohighlight">\(c\)</span> are mandatory and <span class="math notranslate nohighlight">\(A\)</span> or <span class="math notranslate nohighlight">\(B\)</span> is also required.
The other bound and the value for <span class="math notranslate nohighlight">\(t\)</span> can be obtained from the structure of <span class="math notranslate nohighlight">\(c\)</span>, since:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">len(c)</span> <span class="pre">==</span> <span class="pre">t</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">len(c[*])</span> <span class="pre">==</span> <span class="pre">A</span> <span class="pre">+</span> <span class="pre">B</span> <span class="pre">+</span> <span class="pre">1</span></code>.</p></li>
</ul>
<p>If some of the optional arguments is given, it is used as sanity checks on the input of <code class="docutils literal notranslate"><span class="pre">c</span></code>. If the user
pretend to obtain the compatibility in more sections than given with the coefficients, consider the method
<a class="reference internal" href="#pseries_basis.psbasis.Compatibility.in_sections" title="pseries_basis.psbasis.Compatibility.in_sections"><code class="xref py py-func docutils literal notranslate"><span class="pre">in_sections()</span></code></a> after the creation of the basic compatibility.</p>
<p>TODO: add examples from the use of <a class="reference internal" href="#pseries_basis.psbasis.PSBasis" title="pseries_basis.psbasis.PSBasis"><code class="xref py py-class docutils literal notranslate"><span class="pre">PSBasis</span></code></a>.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="pseries_basis.psbasis.Compatibility.A">
<span class="sig-name descname"><span class="pre">A</span></span><a class="headerlink" href="#pseries_basis.psbasis.Compatibility.A" title="Permalink to this definition">¶</a></dt>
<dd><p>alias for the upper bound</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pseries_basis.psbasis.Compatibility.B">
<span class="sig-name descname"><span class="pre">B</span></span><a class="headerlink" href="#pseries_basis.psbasis.Compatibility.B" title="Permalink to this definition">¶</a></dt>
<dd><p>alias for the lower bound</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pseries_basis.psbasis.Compatibility.add">
<span class="sig-name descname"><span class="pre">add</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pseries_basis.psbasis.Compatibility.add" title="Permalink to this definition">¶</a></dt>
<dd><p>Method to compute the compatibility of the sum of the two compatibilities.</p>
<p>One of the main results in <a class="reference external" href="https://dx.doi.org/10.1016/j.jsc.2022.11.002">doi:10.1016/j.jsc.2022.11.002</a> is that whenever
a basis is compatible with two linear operators, then it is compatible with the sum of 
the operators.</p>
<p>When we take into account the bounds of the compatibilities and the sections, the 
final statement is the following: let <span class="math notranslate nohighlight">\(L_1\)</span> be a <span class="math notranslate nohighlight">\((A_1,B_1)\)</span>-compatible operator
in <span class="math notranslate nohighlight">\(t_1\)</span> sections and <span class="math notranslate nohighlight">\(L_2\)</span> be a <span class="math notranslate nohighlight">\((A_2, B_2)\)</span>-compatible operator in <span class="math notranslate nohighlight">\(t_2\)</span> sections.
Then <span class="math notranslate nohighlight">\(L_1 + L_2\)</span> is a <span class="math notranslate nohighlight">\((A,B)\)</span>-compatible operator in <span class="math notranslate nohighlight">\(t\)</span> sections where</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(A = \max(A_1,A_2)\)</span>,</p></li>
<li><p><span class="math notranslate nohighlight">\(B = \min(B_1,B_2)\)</span>,</p></li>
<li><p><span class="math notranslate nohighlight">\(t = \text{lcm}(t_1,t_2)\)</span>.</p></li>
</ul>
<p>This method return the corresponding compatibility for the addition of two operators
from the compatibilities of these two operators.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">other</span></code>: a new compatibility condition that will <em>added</em> to <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p></li>
</ul>
<p>OUTPUT:</p>
<p>A new <a class="reference internal" href="#pseries_basis.psbasis.Compatibility" title="pseries_basis.psbasis.Compatibility"><code class="xref py py-class docutils literal notranslate"><span class="pre">Compatibility</span></code></a> for the operator obtained as the addition of the operators
that defined <code class="docutils literal notranslate"><span class="pre">self</span></code> and <code class="docutils literal notranslate"><span class="pre">other</span></code>.</p>
<p>TODO: add examples</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pseries_basis.psbasis.Compatibility.base">
<span class="sig-name descname"><span class="pre">base</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pseries_basis.psbasis.Compatibility.base" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the common universe of the sequences in the compatibility coefficients</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pseries_basis.psbasis.Compatibility.change_base">
<span class="sig-name descname"><span class="pre">change_base</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">new_base</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pseries_basis.psbasis.Compatibility.change_base" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a new compatibility condition changing the universe of the sequences to a new ring</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pseries_basis.psbasis.Compatibility.data">
<span class="sig-name descname"><span class="pre">data</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pseries_basis.psbasis.Compatibility.data" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the compatibility data (<span class="math notranslate nohighlight">\(A\)</span>, <span class="math notranslate nohighlight">\(B\)</span>, <span class="math notranslate nohighlight">\(t\)</span>)</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pseries_basis.psbasis.Compatibility.equiv">
<span class="sig-name descname"><span class="pre">equiv</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bound</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pseries_basis.psbasis.Compatibility.equiv" title="Permalink to this definition">¶</a></dt>
<dd><p>Check equivalence between compatibility conditions</p>
<p>This method defines the equivalence between two compatibility conditions.
Let <span class="math notranslate nohighlight">\(C_1\)</span> and <span class="math notranslate nohighlight">\(C_2\)</span> be two compatibility conditions with general data 
<span class="math notranslate nohighlight">\((A_1,B_1,t_1)\)</span> and <span class="math notranslate nohighlight">\((A_2,B_2,t_2)\)</span> and coefficients <span class="math notranslate nohighlight">\(\alpha_{b,i}(n)\)</span> and 
<span class="math notranslate nohighlight">\(\beta_{b,i}(n)\)</span> respectively.</p>
<ul>
<li><p>If <span class="math notranslate nohighlight">\(t_1 \neq t_2\)</span>, we say <span class="math notranslate nohighlight">\(C_1 \equiv C_2\)</span> if and only if <span class="math notranslate nohighlight">\(C_1(t) \equiv C_2(t)\)</span>,
where <span class="math notranslate nohighlight">\(t = \lcm(t_1,t_2)\)</span> and <span class="math notranslate nohighlight">\(C_*(t)\)</span> is the compatibility <span class="math notranslate nohighlight">\(C_*\)</span> in <span class="math notranslate nohighlight">\(t\)</span> sections 
(see method <a class="reference internal" href="#pseries_basis.psbasis.Compatibility.in_sections" title="pseries_basis.psbasis.Compatibility.in_sections"><code class="xref py py-func docutils literal notranslate"><span class="pre">in_sections()</span></code></a>)</p></li>
<li><p>If <span class="math notranslate nohighlight">\(t_1 = t_2\)</span>, then we check the equality of</p>
<div class="math notranslate nohighlight">
\[\alpha_{b,i}(n) = \beta_{b,i}(n) \ \text{for } b=0,\ldots,t_1-1;\ i=-\max\{A_1,A_2\},\ldots,\max{B_1,B-2\};\ n=0,\ldots,\text{bound}.\]</div>
<p>where the <code class="docutils literal notranslate"><span class="pre">bound</span></code> is given with the optional argument of this method. If not given, we will
use the default bound for almost equality of the module <a class="reference internal" href="sequences.html#module-pseries_basis.sequences" title="pseries_basis.sequences"><code class="xref py py-mod docutils literal notranslate"><span class="pre">sequences</span></code></a>.</p>
</li>
</ul>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">other</span></code>: a <a class="reference internal" href="#pseries_basis.psbasis.Compatibility" title="pseries_basis.psbasis.Compatibility"><code class="xref py py-class docutils literal notranslate"><span class="pre">Compatibility</span></code></a> to be checked.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">bound</span></code> (optional): bound for equality of sequences to be used.</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pseries_basis.psbasis.Compatibility.in_sections">
<span class="sig-name descname"><span class="pre">in_sections</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">new_sections</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pseries_basis.psbasis.Compatibility.in_sections" title="Permalink to this definition">¶</a></dt>
<dd><p>Method to compute the compatibility condition with respect to more sections.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pseries_basis.psbasis.Compatibility.lower">
<span class="sig-name descname"><span class="pre">lower</span></span><a class="headerlink" href="#pseries_basis.psbasis.Compatibility.lower" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pseries_basis.psbasis.Compatibility.mul">
<span class="sig-name descname"><span class="pre">mul</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pseries_basis.psbasis.Compatibility.mul" title="Permalink to this definition">¶</a></dt>
<dd><p>Method to compute the compatibility of the product/composition of the two compatibilities.</p>
<p>One of the main results in <a class="reference external" href="https://dx.doi.org/10.1016/j.jsc.2022.11.002">doi:10.1016/j.jsc.2022.11.002</a> is that whenever
a basis is compatible with two linear operators, then it is compatible with the product
(i.e., the composition) of the operators.</p>
<p>When we take into account the bounds of the compatibilities and the sections, the 
final statement is the following: let <span class="math notranslate nohighlight">\(L_1\)</span> be a <span class="math notranslate nohighlight">\((A_1,B_1)\)</span>-compatible operator
in <span class="math notranslate nohighlight">\(t_1\)</span> sections and <span class="math notranslate nohighlight">\(L_2\)</span> be a <span class="math notranslate nohighlight">\((A_2, B_2)\)</span>-compatible operator in <span class="math notranslate nohighlight">\(t_2\)</span> sections.
Then <span class="math notranslate nohighlight">\(L_1 + L_2\)</span> is a <span class="math notranslate nohighlight">\((A,B)\)</span>-compatible operator in <span class="math notranslate nohighlight">\(t\)</span> sections where</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(A = A_1+A_2\)</span>,</p></li>
<li><p><span class="math notranslate nohighlight">\(B = B_1+B_2\)</span>,</p></li>
<li><p><span class="math notranslate nohighlight">\(t = \text{lcm}(t_1,t_2)\)</span>.</p></li>
</ul>
<p>This method return the corresponding compatibility for the product of two operators
from the compatibilities of these two operators.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">other</span></code>: a new compatibility condition that will <em>multiplied</em> to <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p></li>
</ul>
<p>OUTPUT:</p>
<p>A new <a class="reference internal" href="#pseries_basis.psbasis.Compatibility" title="pseries_basis.psbasis.Compatibility"><code class="xref py py-class docutils literal notranslate"><span class="pre">Compatibility</span></code></a> for the operator obtained as the product of the operators
that defined <code class="docutils literal notranslate"><span class="pre">self</span></code> and <code class="docutils literal notranslate"><span class="pre">other</span></code>.</p>
<p>TODO: add examples</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pseries_basis.psbasis.Compatibility.nsections">
<span class="sig-name descname"><span class="pre">nsections</span></span><a class="headerlink" href="#pseries_basis.psbasis.Compatibility.nsections" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pseries_basis.psbasis.Compatibility.scale">
<span class="sig-name descname"><span class="pre">scale</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">factor</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pseries_basis.psbasis.Compatibility.scale" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pseries_basis.psbasis.Compatibility.scale_basis">
<span class="sig-name descname"><span class="pre">scale_basis</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">factor</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pseries_basis.psbasis.Compatibility.scale_basis" title="Permalink to this definition">¶</a></dt>
<dd><p>Method that computes the equivalent compatibility for the scaled basis.</p>
<p>Let us assume that a <a class="reference internal" href="#pseries_basis.psbasis.Compatibility" title="pseries_basis.psbasis.Compatibility"><code class="xref py py-class docutils literal notranslate"><span class="pre">Compatibility</span></code></a> is associated with a basis <span class="math notranslate nohighlight">\(P_k(n)\)</span>. Now,
assume we consider the scaled basis <span class="math notranslate nohighlight">\(Q_k(n) = c(k)P_k(n)\)</span>. Then the operator
of <code class="docutils literal notranslate"><span class="pre">self</span></code> is also compatible with the new basis and such compatibility is closely related
with <code class="docutils literal notranslate"><span class="pre">self</span></code>. Namely, for <span class="math notranslate nohighlight">\(k = mt + r\)</span></p>
<div class="math notranslate nohighlight">
\[L Q_k(n) = c(k) L P_k(n) = c(k) \sum_{i=-A}^B \alpha_{r,i}(m) P_{k+i}(n) = \sum_{i=-A}^B \alpha_{r,i}(m) \frac{c(k)}{c(k+i)}Q_{k+i}(n)\]</div>
<p>Then the compatibility of <span class="math notranslate nohighlight">\(L\)</span> w.r.t. <span class="math notranslate nohighlight">\(Q_k(n)\)</span> is again <span class="math notranslate nohighlight">\((A,B)\)</span>-compatible in <span class="math notranslate nohighlight">\(t\)</span> sections and the new compatibility coefficients are:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">..</span> <span class="n">MATH</span><span class="p">::</span>
</pre></div>
</div>
<blockquote>
<div><p>tilde{alpha}_{r,i}(m) = alpha_{r,i}(m) frac{c(mt+r)}{c(mt+r+i)}</p>
</div></blockquote>
<p>This computation has several layers of simplification:</p>
<ul class="simple">
<li><p>If the sequence <span class="math notranslate nohighlight">\(c(k)\)</span> is a <code class="xref py py-class docutils literal notranslate"><span class="pre">RationalSequence</span></code>, then all the quotients <span class="math notranslate nohighlight">\(\frac{c(mt+r)}{c(mt+r+i)}\)</span> are again rational sequences, 
hence we can use these computations right away.</p></li>
<li><p>If the sequence <span class="math notranslate nohighlight">\(c(k)\)</span> is <strong>not</strong> rational but it is hypergeometric. Then <span class="math notranslate nohighlight">\(c(k+1)/c(k)\)</span> is a rational function and all the quotients necessary 
can be computed as rational sequences.</p></li>
<li><p>Otherwise, we simply compute the values as they appear in the formula and hope they are useful later on.</p></li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pseries_basis.psbasis.Compatibility.t">
<span class="sig-name descname"><span class="pre">t</span></span><a class="headerlink" href="#pseries_basis.psbasis.Compatibility.t" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pseries_basis.psbasis.Compatibility.upper">
<span class="sig-name descname"><span class="pre">upper</span></span><a class="headerlink" href="#pseries_basis.psbasis.Compatibility.upper" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pseries_basis.psbasis.basis_matrix">
<span class="sig-prename descclassname"><span class="pre">pseries_basis.psbasis.</span></span><span class="sig-name descname"><span class="pre">basis_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">basis</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nrows</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ncols</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">section</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shift</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pseries_basis.psbasis.basis_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Method to build a matrix with the first part of a basis or a 2-size sequence.</p>
<p>This method allow the optional arguments <code class="docutils literal notranslate"><span class="pre">section</span></code> and shift`` in order to take a subsequence of the basis.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pseries_basis.psbasis.check_compatibility">
<span class="sig-prename descclassname"><span class="pre">pseries_basis.psbasis.</span></span><span class="sig-name descname"><span class="pre">check_compatibility</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">basis</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">compatibility</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">action</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bound</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">_full</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pseries_basis.psbasis.check_compatibility" title="Permalink to this definition">¶</a></dt>
<dd><p>Method that checks whether a basis has a particular compatibility for a given action.</p>
<p>This method takes a <a class="reference internal" href="#pseries_basis.psbasis.PSBasis" title="pseries_basis.psbasis.PSBasis"><code class="xref py py-class docutils literal notranslate"><span class="pre">PSBasis</span></code></a> (i.e., a sequence of sequences), a given
operator compatible with it (or simply the <a class="reference internal" href="#pseries_basis.psbasis.Compatibility" title="pseries_basis.psbasis.Compatibility"><code class="xref py py-class docutils literal notranslate"><span class="pre">Compatibility</span></code></a> object representing
such compatibility) and check whether the action that is defined for the operator/compatibility
(which is provided by the argument <code class="docutils literal notranslate"><span class="pre">action</span></code>) has precisely this compatibility.</p>
<p>More precisely, if an operator <span class="math notranslate nohighlight">\(L\)</span> the operator is <span class="math notranslate nohighlight">\((A,B)\)</span>-compatible with the basis <span class="math notranslate nohighlight">\(P=(P_n)_n\)</span> 
with the formula:</p>
<div class="math notranslate nohighlight">
\[L P_n = \sum_{i=-A}^B \alpha_{n,i}P_{n+i},\]</div>
<p>then this method checks this identity for the <code class="docutils literal notranslate"><span class="pre">action</span></code> defining <span class="math notranslate nohighlight">\(L\)</span>, and the compatibility
condition <span class="math notranslate nohighlight">\((A,B,m,\alpha)\)</span> defined in <code class="docutils literal notranslate"><span class="pre">compatibility</span></code>.</p>
<p>This checking is perform until a given <span class="math notranslate nohighlight">\(n\)</span> bounded by the input <code class="docutils literal notranslate"><span class="pre">bound</span></code>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">basis</span></code>: a <a class="reference internal" href="#pseries_basis.psbasis.PSBasis" title="pseries_basis.psbasis.PSBasis"><code class="xref py py-class docutils literal notranslate"><span class="pre">PSBasis</span></code></a> that defines the basis <span class="math notranslate nohighlight">\(P=(P_n)_n\)</span>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">compatibility</span></code>: a compatibility condition. If an operator is given, then compatibility condition
for <code class="docutils literal notranslate"><span class="pre">basis</span></code> is computed (check method <a class="reference internal" href="#pseries_basis.psbasis.PSBasis.compatibility" title="pseries_basis.psbasis.PSBasis.compatibility"><code class="xref py py-func docutils literal notranslate"><span class="pre">PSBasis.compatibility()</span></code></a>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">action</span></code>: a callable that actually computes the element <span class="math notranslate nohighlight">\(L P_n\)</span> so it can be compared.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">bound</span></code>: a bound for the limit this equality will be checked. Since <span class="math notranslate nohighlight">\(L P_n\)</span> is a sequence
this bound is used both for checking equality at each level <span class="math notranslate nohighlight">\(n\)</span> and until which level the 
identity is checked.</p></li>
</ul>
<p>OUTPUT:</p>
<p><code class="docutils literal notranslate"><span class="pre">True</span></code> if all the checking provide equality, and <code class="docutils literal notranslate"><span class="pre">False</span></code> otherwise. Be cautious when reading
this output: <code class="docutils literal notranslate"><span class="pre">False</span></code> guarantees that the compatibility is <strong>not</strong> for the action, however, <code class="docutils literal notranslate"><span class="pre">True</span></code>
provides a nice hint the result should be True, but it is not a complete proof.</p>
<p>TODO: add examples</p>
</dd></dl>

</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <div>
    <h4>Previous topic</h4>
    <p class="topless"><a href="../index.html"
                          title="previous chapter">Inverse Zeibelger Problem</a></p>
  </div>
  <div>
    <h4>Next topic</h4>
    <p class="topless"><a href="sequences.html"
                          title="next chapter">Infinite Sequences Framework: working with sequences in SageMath</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/pseries_basis/psbasis.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="sequences.html" title="Infinite Sequences Framework: working with sequences in SageMath"
             >next</a> |</li>
        <li class="right" >
          <a href="../index.html" title="Inverse Zeibelger Problem"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">pseries_basis</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Power Series basis: basic structure and functionality</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2022.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 4.4.0.
    </div>
  </body>
</html>