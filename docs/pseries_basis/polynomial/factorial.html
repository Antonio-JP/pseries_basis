
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>Factorial Basis: simplest Polynomial basis &#8212; Inverse Zeibelger Problem: Power Series basis for Sage 0.4.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/classic.css" />
    
    <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Generalized Binomial Bases" href="orthogonal.html" />
    <link rel="prev" title="Polynomial Bases: basic bases for formal power series" href="../polynomial.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="orthogonal.html" title="Generalized Binomial Bases"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="../polynomial.html" title="Polynomial Bases: basic bases for formal power series"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">pseries_basis</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../polynomial.html" accesskey="U">Polynomial Bases: basic bases for formal power series</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Factorial Basis: simplest Polynomial basis</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="module-pseries_basis.polynomial.factorial">
<span id="factorial-basis-simplest-polynomial-basis"></span><h1>Factorial Basis: simplest Polynomial basis<a class="headerlink" href="#module-pseries_basis.polynomial.factorial" title="Permalink to this headline">¶</a></h1>
<p>Sage package for Factorial Series Basis.</p>
<p>A factorial basis is a specific type of Sequences basis where the elements
are defined using a recurrence of order 1. This can be seen also as a specific
type of hypergeometric sequence of sequences.</p>
<p>More precisely, a factorial basis is a basis of sequences <span class="math notranslate nohighlight">\(B = \{P_k(n)\}\)</span> where 
the <span class="math notranslate nohighlight">\(k\)</span>-th element is a polynomial sequence of degree <span class="math notranslate nohighlight">\(k\)</span> such that</p>
<div class="math notranslate nohighlight">
\[P_{k+1}(n) = (a_{k}n + b_{k})P_{k}.\]</div>
<p>This lead to specific types of compatibility as sequences as described in <a class="reference external" href="https://dx.doi.org/10.1016/j.jsc.2022.11.002">doi:10.1016/j.jsc.2022.11.002</a>.
For example, the “multiplication by <span class="math notranslate nohighlight">\(n\)</span>” operation is always compatible with a factorial basis since:</p>
<div class="math notranslate nohighlight">
\[nP_k = \frac{1}{a_k}P_{k+1}(n) - \frac{b_k}{a_k}P_k.\]</div>
<p>This module includes the main class for working with factorial basis, all falling down 
into the two defining sequences <span class="math notranslate nohighlight">\(a_k\)</span> and <span class="math notranslate nohighlight">\(b_k\)</span> (see class <a class="reference internal" href="#pseries_basis.polynomial.factorial.FactorialBasis" title="pseries_basis.polynomial.factorial.FactorialBasis"><code class="xref py py-class docutils literal notranslate"><span class="pre">FactorialBasis</span></code></a>). This 
class will be then created specifically for other types of examples, such as the power basis 
<span class="math notranslate nohighlight">\(\{n^k\}\)</span>, the binomial basis <span class="math notranslate nohighlight">\(\left\{\binom{n}{k}\right\}\)</span> and falling-type basis.</p>
<dl class="py class">
<dt class="sig sig-object py" id="pseries_basis.polynomial.factorial.FactorialBasis">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pseries_basis.polynomial.factorial.</span></span><span class="sig-name descname"><span class="pre">FactorialBasis</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ak</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bk</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">universe</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">beta</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gamma</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">as_2seq</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">_extend_by_zero</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwds</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pseries_basis.polynomial.factorial.FactorialBasis" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="../psbasis.html#pseries_basis.psbasis.PSBasis" title="pseries_basis.psbasis.PSBasis"><code class="xref py py-class docutils literal notranslate"><span class="pre">pseries_basis.psbasis.PSBasis</span></code></a></p>
<p>Class representing a Factorial Basis.</p>
<p>A <span class="math notranslate nohighlight">\(beta(n)\)</span>-factorial basis is a specific type of Sequences basis where the elements
are defined using a recurrence of order 1. This can be seen also as a specific
type of hypergeometric sequence of sequences.</p>
<p>More precisely, a <span class="math notranslate nohighlight">\(\beta(n)\)</span>-factorial basis is a basis of sequences <span class="math notranslate nohighlight">\(B = \{P_k(n)\}\)</span> where 
the <span class="math notranslate nohighlight">\(k\)</span>-th element is a polynomial w.r.t. <span class="math notranslate nohighlight">\(\beta(n)\)</span> of degree <span class="math notranslate nohighlight">\(k\)</span> such that</p>
<div class="math notranslate nohighlight">
\[P_{k+1}(n) = (a_{k}\beta(n) + b_{k})P_{k}(n).\]</div>
<p>This type of basis have special types of compatibilities. More precisely, they are 
<strong>always</strong> compatible with the “multiplication by <span class="math notranslate nohighlight">\(\beta(n)\)</span>” operation. This is a special type
of homomorphism, and always satisfies:</p>
<div class="math notranslate nohighlight">
\[\beta(n)P_k = \frac{1}{a_k}P_{k+1}(n) - \frac{b_k}{a_k}P_k(n).\]</div>
<p>Besides the sequences <span class="math notranslate nohighlight">\((a_k)_k\)</span> and <span class="math notranslate nohighlight">\((b_k)_k\)</span> that define the elements of the basis, 
there are two other equivalent sequences: the root sequences and the leading coefficient sequence:</p>
<div class="math notranslate nohighlight">
\[\rho_{k+1} = \frac{-b_k}{a_k},\qquad c_k = \prod_{l=1}^k a_l.\]</div>
<p>The root sequence <span class="math notranslate nohighlight">\(\rho_k\)</span> defines for each element the new root added to the element <span class="math notranslate nohighlight">\(P_k(n)\)</span>. On the 
other hand, the leading coefficient sequence provides the leading coefficient of the polynomial <span class="math notranslate nohighlight">\(P_k(n)\)</span>.
Then, there are two main criteria to determine whether a <span class="math notranslate nohighlight">\(\beta(n)\)</span>-factorial sequence is compatible with an 
homomorphism and a derivation (see <a class="reference external" href="https://dx.doi.org/10.1016/j.jsc.2022.11.002">doi:10.1016/j.jsc.2022.11.002</a>, Propositions 14 and 16).</p>
<p>INPUT:</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">ak</span></code>: a sequence to be used for <span class="math notranslate nohighlight">\(a_k\)</span>. It can be a rational expression in some variable (see argument <code class="docutils literal notranslate"><span class="pre">gamma</span></code>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">bk</span></code>: a sequence to be used for <span class="math notranslate nohighlight">\(b_k\)</span>. See argument <code class="docutils literal notranslate"><span class="pre">ak</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">universe</span></code> (optional): universe for the elements of the basis.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">beta</span></code>: either <code class="docutils literal notranslate"><span class="pre">None</span></code> or a tuple <code class="docutils literal notranslate"><span class="pre">(name,</span> <span class="pre">seq)</span></code>. This defines the sequence <span class="math notranslate nohighlight">\(beta(n)\)</span> and a name for it. If
not given, it takes as default the values <code class="docutils literal notranslate"><span class="pre">(`n`,</span> <span class="pre">n</span> <span class="pre">-&gt;</span> <span class="pre">n)</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">gamma</span></code>: either <code class="docutils literal notranslate"><span class="pre">None</span></code> or a tuple <code class="docutils literal notranslate"><span class="pre">(name,</span> <span class="pre">seq)</span></code>. This defines a sequence <span class="math notranslate nohighlight">\(\gamma(k)\)</span> such that <span class="math notranslate nohighlight">\(a_k\)</span> and <span class="math notranslate nohighlight">\(b_k\)</span>
are built (if necessary) as <code class="xref py py-class docutils literal notranslate"><span class="pre">RationalSequence</span></code> w.r.t. <span class="math notranslate nohighlight">\(gamma(k)\)</span>. By default, it takes the value <code class="docutils literal notranslate"><span class="pre">(`k`,</span> <span class="pre">n</span> <span class="pre">-&gt;</span> <span class="pre">n)</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">as_2seq</span></code> (optional): sequence in 2 variables that will be use for generic purposes in <code class="xref py py-class docutils literal notranslate"><span class="pre">PSBasis</span></code>.</p></li>
</ul>
</div></blockquote>
<dl class="py method">
<dt class="sig sig-object py" id="pseries_basis.polynomial.factorial.FactorialBasis.args_to_self">
<span class="sig-name descname"><span class="pre">args_to_self</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pseries_basis.polynomial.factorial.FactorialBasis.args_to_self" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pseries_basis.polynomial.factorial.FactorialBasis.ak">
<span class="sig-name descname"><span class="pre">ak</span></span><a class="headerlink" href="#pseries_basis.polynomial.factorial.FactorialBasis.ak" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pseries_basis.polynomial.factorial.FactorialBasis.bk">
<span class="sig-name descname"><span class="pre">bk</span></span><a class="headerlink" href="#pseries_basis.polynomial.factorial.FactorialBasis.bk" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pseries_basis.polynomial.factorial.FactorialBasis.rho">
<span class="sig-name descname"><span class="pre">rho</span></span><a class="headerlink" href="#pseries_basis.polynomial.factorial.FactorialBasis.rho" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pseries_basis.polynomial.factorial.FactorialBasis.lc">
<span class="sig-name descname"><span class="pre">lc</span></span><a class="headerlink" href="#pseries_basis.polynomial.factorial.FactorialBasis.lc" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pseries_basis.polynomial.factorial.FactorialBasis.gen">
<span class="sig-name descname"><span class="pre">gen</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pseries_basis.polynomial.factorial.FactorialBasis.gen" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pseries_basis.polynomial.factorial.FactorialBasis.poly_ring">
<span class="sig-name descname"><span class="pre">poly_ring</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pseries_basis.polynomial.factorial.FactorialBasis.poly_ring" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pseries_basis.polynomial.factorial.FactorialBasis.increasing_basis">
<span class="sig-name descname"><span class="pre">increasing_basis</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">shift</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pseries_basis.polynomial.factorial.FactorialBasis.increasing_basis" title="Permalink to this definition">¶</a></dt>
<dd><p>Method to obtain a <span class="math notranslate nohighlight">\(k\)</span>-th increasing basis.</p>
<p>A factorial basis is defined by the first order recurrence on sequences:</p>
<div class="math notranslate nohighlight">
\[P_{k+1}(n) = \left(a_k n + b_k\right)P_k(n).\]</div>
<p>This implies that the sequence <span class="math notranslate nohighlight">\(P_k(n)\)</span> is always a polynomial sequence of degree 
exactly <span class="math notranslate nohighlight">\(k\)</span> and that <span class="math notranslate nohighlight">\(P_k(n)\)</span> divides (in terms of polynomial division) the following
element of the basis. Let us consider the polynomials <span class="math notranslate nohighlight">\(Q^{(k)}_t(n)\)</span> defined by:</p>
<div class="math notranslate nohighlight">
\[Q^{(k)}_t(n) = \frac{P_{k+t}(n)}{P_k(n)}.\]</div>
<p>It is clear by definition that <span class="math notranslate nohighlight">\(Q^{(k)}_t(n)\)</span> is a polynomial of degree exactly <span class="math notranslate nohighlight">\(t\)</span> and,
moreover, it satisfies the following first order recurrence as sequences:</p>
<div class="math notranslate nohighlight">
\[Q^{(k)}_{t+1}(n) = \left(a_{k+t} n + b_{k+t}\right) Q^{(k)}_t(n).\]</div>
<p>Hence the set of polynomials <span class="math notranslate nohighlight">\(\{Q^{(k)}_t(n)\}_t\)</span> is again a factorial basis. This method 
returns this new factorial basis for <code class="docutils literal notranslate"><span class="pre">shift</span></code> taking the value of <span class="math notranslate nohighlight">\(k\)</span>.</p>
<p>TODO: add tests</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pseries_basis.polynomial.factorial.FactorialBasis.compatible_division">
<span class="sig-name descname"><span class="pre">compatible_division</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">operator</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pseries_basis.polynomial.factorial.FactorialBasis.compatible_division" title="Permalink to this definition">¶</a></dt>
<dd><p>Method to compute the division condition for a given operator.</p>
<p>The division condition for a compatible operator comes from the equivalence in <a class="reference external" href="https://dx.doi.org/10.1016/j.jsc.2022.11.002">doi:10.1016/j.jsc.2022.11.002</a>, Proposition 11. 
For further information, check the class <a class="reference internal" href="#pseries_basis.polynomial.factorial.DivisionCondition" title="pseries_basis.polynomial.factorial.DivisionCondition"><code class="xref py py-class docutils literal notranslate"><span class="pre">DivisionCondition</span></code></a></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pseries_basis.polynomial.factorial.FactorialBasis.matrix_ItP">
<span class="sig-name descname"><span class="pre">matrix_ItP</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">size</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">section</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pseries_basis.polynomial.factorial.FactorialBasis.matrix_ItP" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the matrix that transforms the polynomial basis given by <code class="docutils literal notranslate"><span class="pre">self</span></code> into the associated power basis.</p>
<p>Let <span class="math notranslate nohighlight">\(\{P_k(n)\}\)</span> be a <span class="math notranslate nohighlight">\(\beta(n)\)</span>-factorial basis. Then, the element <span class="math notranslate nohighlight">\(P_k(n)\)</span> is a polynomial in <span class="math notranslate nohighlight">\(\beta(n)\)</span> 
of degree exactly <span class="math notranslate nohighlight">\(k\)</span> and, moreover, the polynomial <span class="math notranslate nohighlight">\(P_k(n)\)</span> divides <span class="math notranslate nohighlight">\(P_K(n)\)</span> for all <span class="math notranslate nohighlight">\(k \leq K\)</span>. This implies
that for any fixed <span class="math notranslate nohighlight">\(k \in \mathbb{N}\)</span> the sequence <span class="math notranslate nohighlight">\(\left(\frac{P_{k+i}(n)}{P_k(i)}\right)_i\)</span> is a sequence
of polynomials of degree <span class="math notranslate nohighlight">\(i\)</span> and, hence, a basis of the polynomial ring.</p>
<p>This method computes the matrix of fixed <code class="docutils literal notranslate"><span class="pre">size</span></code> that write the polynomials <span class="math notranslate nohighlight">\(\frac{P_{k+i}(n)}{P_k(i)}\)</span> 
into the power basis <span class="math notranslate nohighlight">\(\beta(n)^i\)</span>.</p>
<p>For doing so, the only information we have is the <span class="math notranslate nohighlight">\((1,0)\)</span>-compatibility of the <a class="reference internal" href="#pseries_basis.polynomial.factorial.FactorialBasis" title="pseries_basis.polynomial.factorial.FactorialBasis"><code class="xref py py-class docutils literal notranslate"><span class="pre">FactorialBasis</span></code></a> with 
the multiplication by <span class="math notranslate nohighlight">\(\beta(n)\)</span> (see <code class="docutils literal notranslate"><span class="pre">self.compatibility(self.gen())</span></code>). Let us assume that <span class="math notranslate nohighlight">\(\beta(n)\)</span> 
is compatible in <span class="math notranslate nohighlight">\(t\)</span> for <span class="math notranslate nohighlight">\(r \in \{0,\ldots, t-1\}\)</span>. Then:</p>
<div class="math notranslate nohighlight">
\[\beta(n)^i P_{mt+r}(n) = \sum_{j=0}^i \alpha_{r,j}^{(i)}(m)P_{mt+r+j},\]</div>
<p>where the <span class="math notranslate nohighlight">\(\alpha_r,j}^{(i)}(m)\)</span> are the compatibility coefficients of the multiplication by <span class="math notranslate nohighlight">\(\beta(n)^i\)</span>. Then,
we can write these identities in a matri-vector multiplication format:</p>
<div class="math notranslate nohighlight">
\[\begin{split}P_{mt+r}(n) \begin{pmatrix} 1\\ \beta(n) \\ \beta(n)^2 \\ \vdots \\ \beta(n)^{S-1} \end{pmatrix} = 
\begin{pmatrix}
    1 &amp; 0 &amp; 0 &amp; \ldots &amp; 0 \\
    \alpha_{r,0}^{(1)}(m) &amp; \alpha_{r,1}^{(1)}(m) &amp; 0 &amp; \ldots &amp; 0 \\
    \alpha_{r,0}^{(2)}(m) &amp; \alpha_{r,1}^{(2)}(m) &amp; \alpha_{r,2}^{(2)}(m) &amp; \ldots &amp; 0 \\
    \vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
    \alpha_{r,0}^{(S-1)}(m) &amp; \alpha_{r,1}^{(S-1)}(m) &amp; \alpha_{r,2}^{(S-1)}(m) &amp; \ldots &amp; \alpha_{r,S-1}^{(S-1)}(m)
\end{pmatrix}
\begin{pmatrix} P_{mt+r}(n)\\ P_{mt+r+1}(n) \\ P_{mt+r+2}(n) \\ \vdots \\ P_{mt+r+S-1}(n)\end{pmatrix}\end{split}\]</div>
<p>This matrix is lower-triangular and has a non-zero determinant (since we know the degrees of the polynomials are exact). Hence,
this matrix is always invertible. Multiplying by its inverse from the left and dividing the whole equation by <span class="math notranslate nohighlight">\(P_{mt+r}\)</span> we
obtain formulas for <span class="math notranslate nohighlight">\(\frac{P_{mt+r+i}(n)}{P_{mt+r}(n)}\)</span> with respect to <span class="math notranslate nohighlight">\(\beta(n)\)</span> (i.e., transforming the increasing basis 
(see method <code class="xref py py-func docutils literal notranslate"><span class="pre">increasin_basis()</span></code>) into the power basis).</p>
<p>REMARK: in order to get information about the matrix for <span class="math notranslate nohighlight">\(k = mt+r\)</span>, we need to know the exact <span class="math notranslate nohighlight">\(r\)</span> that we are considering. That
is why we ask for an input <code class="docutils literal notranslate"><span class="pre">section</span></code> in the method, that will be automatically handled when having simply one section.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">size</span></code>: size of the matrix ti be considered. (May be used in the future to improve performance in this method)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">section</span></code>: value for <span class="math notranslate nohighlight">\(r\)</span>. This value will always be tuned down depending on the sections of the multiplication 
by <span class="math notranslate nohighlight">\(\beta(n)\)</span>.</p></li>
</ul>
<p>OUTPUT:</p>
<blockquote>
<div><p>A matrix (in format of tuple of tuples) such that the multiplication from the left with the coordinates of a polynomial
of degree at most <code class="docutils literal notranslate"><span class="pre">size-1</span></code> w.r.t. the increasing basis provides the coordinates of that polynomial w.r.t. the power basis 
induced by <span class="math notranslate nohighlight">\(\beta(n)\)</span>.</p>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pseries_basis.polynomial.factorial.FactorialBasis.matrix_PtI">
<span class="sig-name descname"><span class="pre">matrix_PtI</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">size</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">section</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pseries_basis.polynomial.factorial.FactorialBasis.matrix_PtI" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the matrix that transforms the power basis into the polynomial basis given by <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>Let <span class="math notranslate nohighlight">\(\{P_k(n)\}\)</span> be a <span class="math notranslate nohighlight">\(\beta(n)\)</span>-factorial basis. Then, the element <span class="math notranslate nohighlight">\(P_k(n)\)</span> is a polynomial in <span class="math notranslate nohighlight">\(\beta(n)\)</span> 
of degree exactly <span class="math notranslate nohighlight">\(k\)</span> and, moreover, the polynomial <span class="math notranslate nohighlight">\(P_k(n)\)</span> divides <span class="math notranslate nohighlight">\(P_K(n)\)</span> for all <span class="math notranslate nohighlight">\(k \leq K\)</span>. This implies
that for any fixed <span class="math notranslate nohighlight">\(k \in \mathbb{N}\)</span> the sequence <span class="math notranslate nohighlight">\(\left(\frac{P_{k+i}(n)}{P_k(i)}\right)_i\)</span> is a sequence
of polynomials of degree <span class="math notranslate nohighlight">\(i\)</span> and, hence, a basis of the polynomial ring.</p>
<p>This method computes the matrix of fixed <code class="docutils literal notranslate"><span class="pre">size</span></code> that write the polynomials <span class="math notranslate nohighlight">\(\frac{P_{k+i}(n)}{P_k(i)}\)</span> 
into the power basis <span class="math notranslate nohighlight">\(\beta(n)^i\)</span>.</p>
<p>For doing so, the only information we have is the <span class="math notranslate nohighlight">\((1,0)\)</span>-compatibility of the <a class="reference internal" href="#pseries_basis.polynomial.factorial.FactorialBasis" title="pseries_basis.polynomial.factorial.FactorialBasis"><code class="xref py py-class docutils literal notranslate"><span class="pre">FactorialBasis</span></code></a> with 
the multiplication by <span class="math notranslate nohighlight">\(\beta(n)\)</span> (see <code class="docutils literal notranslate"><span class="pre">self.compatibility(self.gen())</span></code>). Let us assume that <span class="math notranslate nohighlight">\(\beta(n)\)</span> 
is compatible in <span class="math notranslate nohighlight">\(t\)</span> for <span class="math notranslate nohighlight">\(r \in \{0,\ldots, t-1\}\)</span>. Then:</p>
<div class="math notranslate nohighlight">
\[\beta(n)^i P_{mt+r}(n) = \sum_{j=0}^i \alpha_{r,j}^{(i)}(m)P_{mt+r+j},\]</div>
<p>where the <span class="math notranslate nohighlight">\(\alpha_r,j}^{(i)}(m)\)</span> are the compatibility coefficients of the multiplication by <span class="math notranslate nohighlight">\(\beta(n)^i\)</span>. Then,
we can write these identities in a matri-vector multiplication format:</p>
<div class="math notranslate nohighlight">
\[\begin{split}P_{mt+r}(n) \begin{pmatrix} 1\\ \beta(n) \\ \beta(n)^2 \\ \vdots \\ \beta(n)^{S-1} \end{pmatrix} = 
\begin{pmatrix}
    1 &amp; 0 &amp; 0 &amp; \ldots &amp; 0 \\
    \alpha_{r,0}^{(1)}(m) &amp; \alpha_{r,1}^{(1)}(m) &amp; 0 &amp; \ldots &amp; 0 \\
    \alpha_{r,0}^{(2)}(m) &amp; \alpha_{r,1}^{(2)}(m) &amp; \alpha_{r,2}^{(2)}(m) &amp; \ldots &amp; 0 \\
    \vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
    \alpha_{r,0}^{(S-1)}(m) &amp; \alpha_{r,1}^{(S-1)}(m) &amp; \alpha_{r,2}^{(S-1)}(m) &amp; \ldots &amp; \alpha_{r,S-1}^{(S-1)}(m)
\end{pmatrix}
\begin{pmatrix} P_{mt+r}(n)\\ P_{mt+r+1}(n) \\ P_{mt+r+2}(n) \\ \vdots \\ P_{mt+r+S-1}(n)\end{pmatrix}\end{split}\]</div>
<p>REMARK: in order to get information about the matrix for <span class="math notranslate nohighlight">\(k = mt+r\)</span>, we need to know the exact <span class="math notranslate nohighlight">\(r\)</span> that we are considering. That
is why we ask for an input <code class="docutils literal notranslate"><span class="pre">section</span></code> in the method, that will be automatically handled when having simply one section.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">size</span></code>: size of the matrix ti be considered. (May be used in the future to improve performance in this method)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">section</span></code>: value for <span class="math notranslate nohighlight">\(r\)</span>. This value will always be tuned down depending on the sections of the multiplication 
by <span class="math notranslate nohighlight">\(\beta(n)\)</span>.</p></li>
</ul>
<p>OUTPUT:</p>
<blockquote>
<div><p>A matrix (in format of tuple of tuples) such that the multiplication from the left with the coordinates of a polynomial
of degree at most <code class="docutils literal notranslate"><span class="pre">size-1</span></code> w.r.t. the power basis induced by <span class="math notranslate nohighlight">\(\beta(n)\)</span> provides the coordinates of that polynomial 
w.r.t. the increasing basis.</p>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pseries_basis.polynomial.factorial.FactorialBasis.equiv_CtD">
<span class="sig-name descname"><span class="pre">equiv_CtD</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">compatibility</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pseries_basis.polynomial.factorial.FactorialBasis.equiv_CtD" title="Permalink to this definition">¶</a></dt>
<dd><p>Method that transforms a compatibility condition with <code class="docutils literal notranslate"><span class="pre">self</span></code> into a division condition.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">compatibility</span></code>: element representing the compatibility condition. If the input is not of type
<code class="xref py py-class docutils literal notranslate"><span class="pre">Compatibility</span></code>, we call the method <code class="xref py py-func docutils literal notranslate"><span class="pre">compatibility()</span></code> to get one out of this input.</p></li>
</ul>
<p>OUTPUT:</p>
<p>The equivalent <a class="reference internal" href="#pseries_basis.polynomial.factorial.DivisionCondition" title="pseries_basis.polynomial.factorial.DivisionCondition"><code class="xref py py-class docutils literal notranslate"><span class="pre">DivisionCondition</span></code></a> related with <code class="docutils literal notranslate"><span class="pre">compatibility</span></code> and this basis.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pseries_basis.polynomial.factorial.FactorialBasis.equiv_DtC">
<span class="sig-name descname"><span class="pre">equiv_DtC</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">division</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pseries_basis.polynomial.factorial.FactorialBasis.equiv_DtC" title="Permalink to this definition">¶</a></dt>
<dd><p>Method that transforms a division condition with <code class="docutils literal notranslate"><span class="pre">self</span></code> into a compatibility condition.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">division</span></code>: element representing the division condition. If the input is not of type
<a class="reference internal" href="#pseries_basis.polynomial.factorial.DivisionCondition" title="pseries_basis.polynomial.factorial.DivisionCondition"><code class="xref py py-class docutils literal notranslate"><span class="pre">DivisionCondition</span></code></a>, we call the method <a class="reference internal" href="#pseries_basis.polynomial.factorial.FactorialBasis.compatible_division" title="pseries_basis.polynomial.factorial.FactorialBasis.compatible_division"><code class="xref py py-func docutils literal notranslate"><span class="pre">compatible_division()</span></code></a> to 
get one out of this input.</p></li>
</ul>
<p>OUTPUT:</p>
<p>The equivalent <code class="xref py py-class docutils literal notranslate"><span class="pre">Compatibility</span></code> related with <code class="docutils literal notranslate"><span class="pre">division</span></code> and this basis.</p>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pseries_basis.polynomial.factorial.RootSequenceBasis">
<span class="sig-prename descclassname"><span class="pre">pseries_basis.polynomial.factorial.</span></span><span class="sig-name descname"><span class="pre">RootSequenceBasis</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rho</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lc</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">universe</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">beta</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gamma</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">as_2seq</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">_extend_by_zero</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwds</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pseries_basis.polynomial.factorial.RootSequenceBasis" title="Permalink to this definition">¶</a></dt>
<dd><p>Factory for creating a factorial basis from the root sequence and sequence of coefficients.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">rho</span></code>: the sequence of roots for the factorial basis.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">lc</span></code>: the sequence of leading coefficients for the factorial basis.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">universe</span></code>: the base universe where the <code class="xref py py-class docutils literal notranslate"><span class="pre">PSBasis</span></code> will be created.</p></li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">beta</span></code>: either <code class="docutils literal notranslate"><span class="pre">None</span></code> or a tuple <code class="docutils literal notranslate"><span class="pre">(name,</span> <span class="pre">seq)</span></code>. This defines the sequence <span class="math notranslate nohighlight">\(beta(n)\)</span> and a name for it. If</dt><dd><p>not given, it takes as default the values <code class="docutils literal notranslate"><span class="pre">(`n`,</span> <span class="pre">n</span> <span class="pre">-&gt;</span> <span class="pre">n)</span></code>.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">gamma</span></code>: either <code class="docutils literal notranslate"><span class="pre">None</span></code> or a tuple <code class="docutils literal notranslate"><span class="pre">(name,</span> <span class="pre">seq)</span></code>. This defines a sequence <span class="math notranslate nohighlight">\(\gamma(k)\)</span> such that <span class="math notranslate nohighlight">\(a_k\)</span> and <span class="math notranslate nohighlight">\(b_k\)</span></dt><dd><p>are built (if necessary) as <code class="xref py py-class docutils literal notranslate"><span class="pre">RationalSequence</span></code> w.r.t. <span class="math notranslate nohighlight">\(gamma(k)\)</span>. By default, it takes the value <code class="docutils literal notranslate"><span class="pre">(`k`,</span> <span class="pre">n</span> <span class="pre">-&gt;</span> <span class="pre">n)</span></code>.</p>
</dd>
</dl>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">variable</span></code> and <code class="docutils literal notranslate"><span class="pre">seq_variable</span></code>: see <a class="reference internal" href="#pseries_basis.polynomial.factorial.FactorialBasis" title="pseries_basis.polynomial.factorial.FactorialBasis"><code class="xref py py-class docutils literal notranslate"><span class="pre">FactorialBasis</span></code></a> for further information.</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sage</span><span class="p">:</span> <span class="kn">from</span> <span class="nn">pseries_basis</span> <span class="kn">import</span> <span class="o">*</span>
<span class="n">sage</span><span class="p">:</span> <span class="n">RootSequenceBasis</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">QQ</span><span class="p">)[:</span><span class="mi">5</span><span class="p">]</span>
<span class="p">[</span><span class="n">Sequence</span> <span class="n">over</span> <span class="p">[</span><span class="n">Rational</span> <span class="n">Field</span><span class="p">]:</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span><span class="o">...</span><span class="p">),</span>
 <span class="n">Sequence</span> <span class="n">over</span> <span class="p">[</span><span class="n">Rational</span> <span class="n">Field</span><span class="p">]:</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span><span class="o">...</span><span class="p">),</span>
 <span class="n">Sequence</span> <span class="n">over</span> <span class="p">[</span><span class="n">Rational</span> <span class="n">Field</span><span class="p">]:</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span><span class="o">...</span><span class="p">),</span>
 <span class="n">Sequence</span> <span class="n">over</span> <span class="p">[</span><span class="n">Rational</span> <span class="n">Field</span><span class="p">]:</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span><span class="o">...</span><span class="p">),</span>
 <span class="n">Sequence</span> <span class="n">over</span> <span class="p">[</span><span class="n">Rational</span> <span class="n">Field</span><span class="p">]:</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span><span class="o">...</span><span class="p">)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pseries_basis.polynomial.factorial.FallingBasis">
<span class="sig-prename descclassname"><span class="pre">pseries_basis.polynomial.factorial.</span></span><span class="sig-name descname"><span class="pre">FallingBasis</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">c</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">universe</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">E</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'E'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pseries_basis.polynomial.factorial.FallingBasis" title="Permalink to this definition">¶</a></dt>
<dd><p>Factory for creating a factorial basis as a falling factorial-type.</p>
<p>This class represent the FactorialBasis formed by the falling factorial basis
for the power series ring <span class="math notranslate nohighlight">\(\mathbb{Q}[[x]]\)</span> with two extra parameters <span class="math notranslate nohighlight">\(a\)</span> and <span class="math notranslate nohighlight">\(b\)</span>:</p>
<div class="math notranslate nohighlight">
\[1,\quad (ax+b),\quad (ax+b)(ax+b-c),\quad (ax+b)(ax+b-c)(ax+b-2c),\dots\]</div>
<p>In the case of <span class="math notranslate nohighlight">\(a = 1\)</span>, <span class="math notranslate nohighlight">\(b = 0\)</span> and <span class="math notranslate nohighlight">\(c = 0\)</span>, we have the usual power basis 
and in the case of <span class="math notranslate nohighlight">\(a=1\)</span>, <span class="math notranslate nohighlight">\(b = 0\)</span> and <span class="math notranslate nohighlight">\(c = \pm 1\)</span> we have the falling (or
raising) factorial basis.</p>
<p>Following the notation in <a class="reference external" href="https://dx.doi.org/10.1016/j.jsc.2022.11.002">doi:10.1016/j.jsc.2022.11.002</a>, these basis
have compatibilities with the multiplication by <span class="math notranslate nohighlight">\(n\)</span> (as any other factorial basis)
and with the homomorphism <span class="math notranslate nohighlight">\(E: n \mapsto n+\frac{c}{a}\)</span>. All other compatible shifts (i.e., 
maps <span class="math notranslate nohighlight">\(E_{\alpha}: n \mapsto n+\alpha)\)</span> are just powers of <span class="math notranslate nohighlight">\(E\)</span>.</p>
<p>To be more precise, we always have:</p>
<div class="math notranslate nohighlight">
\[E P_k(n) = P_k(n + c/a) = P_k(n) + cP_{k-1}(n)\]</div>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">a</span></code>: the natural number corresponding to the parameter <span class="math notranslate nohighlight">\(a\)</span>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">b</span></code>: the shift corresponding to the value <span class="math notranslate nohighlight">\(b\)</span>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">c</span></code>: the value for <span class="math notranslate nohighlight">\(c\)</span></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">universe</span></code>: the universe where the <code class="xref py py-class docutils literal notranslate"><span class="pre">PSBasis</span></code> will live.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">E</span></code>: the name for the operator representing the shift of <span class="math notranslate nohighlight">\(n\)</span> by <span class="math notranslate nohighlight">\(c/a\)</span>. If not given, we will 
consider “E” as default.</p></li>
</ul>
<p>OUTPUT:</p>
<p>The corresponding <a class="reference internal" href="#pseries_basis.polynomial.factorial.FactorialBasis" title="pseries_basis.polynomial.factorial.FactorialBasis"><code class="xref py py-class docutils literal notranslate"><span class="pre">FactorialBasis</span></code></a> with the given compatibilities.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pseries_basis.polynomial.factorial.PowerTypeBasis">
<span class="sig-prename descclassname"><span class="pre">pseries_basis.polynomial.factorial.</span></span><span class="sig-name descname"><span class="pre">PowerTypeBasis</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">universe</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Dn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'Dn'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pseries_basis.polynomial.factorial.PowerTypeBasis" title="Permalink to this definition">¶</a></dt>
<dd><p>Factory for creating power-type basis.</p>
<p>This class represents the <a class="reference internal" href="#pseries_basis.polynomial.factorial.FactorialBasis" title="pseries_basis.polynomial.factorial.FactorialBasis"><code class="xref py py-class docutils literal notranslate"><span class="pre">FactorialBasis</span></code></a> formed by the simplest basis
for the power series: <span class="math notranslate nohighlight">\(1\)</span>, <span class="math notranslate nohighlight">\((an+b)\)</span>, <span class="math notranslate nohighlight">\((an+b)^2\)</span>, etc.</p>
<p>Following the notation in <a class="reference external" href="http://arxiv.org/abs/2202.05550">Arxiv 2202.05550</a>, we can find that these basis
have compatibilities with the multiplication by <span class="math notranslate nohighlight">\(n\)</span> and with the derivation
with respect to <span class="math notranslate nohighlight">\(n\)</span>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">a</span></code>: the element of the value <span class="math notranslate nohighlight">\(a\)</span>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">b</span></code>: the shift corresponding to the value <span class="math notranslate nohighlight">\(b\)</span>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">universe</span></code>: the universe where the <code class="xref py py-class docutils literal notranslate"><span class="pre">PSBasis</span></code> will live.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Dn</span></code>: the name for the operator representing the derivation by <span class="math notranslate nohighlight">\(n\)</span>. If not given, we will
consider <span class="math notranslate nohighlight">\(Dn\)</span> as default.</p></li>
</ul>
<p>TODO: add examples</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pseries_basis.polynomial.factorial.BinomialTypeBasis">
<span class="sig-prename descclassname"><span class="pre">pseries_basis.polynomial.factorial.</span></span><span class="sig-name descname"><span class="pre">BinomialTypeBasis</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">universe</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">E</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'E'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pseries_basis.polynomial.factorial.BinomialTypeBasis" title="Permalink to this definition">¶</a></dt>
<dd><p>Factory for the generic binomial basis.</p>
<p>This class represents a binomial basis with a shift and dilation effect on the
top variable. Namely, a basis of the form</p>
<div class="math notranslate nohighlight">
\[\binom{an+b}{k},\]</div>
<p>where <span class="math notranslate nohighlight">\(a\)</span> is a natural number and <span class="math notranslate nohighlight">\(b\)</span> is a rational number.</p>
<p>In <a class="reference external" href="http://arxiv.org/abs/2202.05550">Arxiv 2202.05550</a> this corresponds to <span class="math notranslate nohighlight">\(\mathfrak{C}_{a,b}\)</span>
and it is compatible with the multiplication by <span class="math notranslate nohighlight">\(n\)</span> and by the shift operator
<span class="math notranslate nohighlight">\(E: n \rightarrow n+1\)</span>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">a</span></code>: the natural number corresponding to the value <span class="math notranslate nohighlight">\(a\)</span>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">b</span></code>: the shift corresponding to the value <span class="math notranslate nohighlight">\(b\)</span>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">universe</span></code>: the main ring where the basis of sequences is defined.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">E</span></code>: the name for the operator representing the shift of <span class="math notranslate nohighlight">\(n\)</span> by <span class="math notranslate nohighlight">\(1\)</span>. If not given, we will
consider “E” as default. The operator of shift by <span class="math notranslate nohighlight">\(1/a\)</span> will be named by adding a <span class="math notranslate nohighlight">\(_t\)</span> to the name.</p></li>
</ul>
<p>OUTPUT:</p>
<p>A <a class="reference internal" href="#pseries_basis.polynomial.factorial.FactorialBasis" title="pseries_basis.polynomial.factorial.FactorialBasis"><code class="xref py py-class docutils literal notranslate"><span class="pre">FactorialBasis</span></code></a> with the corresponding compatibilities and the binomial structure.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pseries_basis.polynomial.factorial.DivisionCondition">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pseries_basis.polynomial.factorial.</span></span><span class="sig-name descname"><span class="pre">DivisionCondition</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">delta</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">A</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">base</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sections</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pseries_basis.polynomial.factorial.DivisionCondition" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>This class represents a division condition for a linear operator over a <a class="reference internal" href="#pseries_basis.polynomial.factorial.FactorialBasis" title="pseries_basis.polynomial.factorial.FactorialBasis"><code class="xref py py-class docutils literal notranslate"><span class="pre">FactorialBasis</span></code></a>.</p>
<p>In <a class="reference external" href="https://dx.doi.org/10.1016/j.jsc.2022.11.002">doi:10.1016/j.jsc.2022.11.002</a>, Proposition 11, the authors showed that the <span class="math notranslate nohighlight">\((A,B)\)</span>-compatibility
of a linear operator <span class="math notranslate nohighlight">\(L\)</span> with a <a class="reference internal" href="#pseries_basis.polynomial.factorial.FactorialBasis" title="pseries_basis.polynomial.factorial.FactorialBasis"><code class="xref py py-class docutils literal notranslate"><span class="pre">FactorialBasis</span></code></a> is equivalent to the following two conditions:</p>
<ol class="arabic simple">
<li><p>For every <span class="math notranslate nohighlight">\(k \geq 0\)</span>, <span class="math notranslate nohighlight">\(\deg(L P_k(n)) \leq k+B\)</span>.</p></li>
<li><p>For every <span class="math notranslate nohighlight">\(k \geq A\)</span>, <span class="math notranslate nohighlight">\(P_{k-A}(n)\)</span> divides <span class="math notranslate nohighlight">\(LP_k(n)\)</span>.</p></li>
</ol>
<p>Recall that a factorial basis is a basis <span class="math notranslate nohighlight">\(P_k(n)\)</span> where the <span class="math notranslate nohighlight">\(k\)</span>-th element is a polynomial in some sequence
<span class="math notranslate nohighlight">\(\beta(n)\)</span> of degree <span class="math notranslate nohighlight">\(k\)</span>. Hence, the degree in condition 1. and the division in condition 2. is seeing as
a polynomial in <span class="math notranslate nohighlight">\(\beta(n)\)</span>.</p>
<p>The equivalence between the condition 1. and 2., and the <span class="math notranslate nohighlight">\((A,B)\)</span>-compatibility is a key computational 
process for factorial bases. This class allows to represent the conditions 1. and 2. fully and provide 
methods to transform these conditions into <code class="xref py py-class docutils literal notranslate"><span class="pre">Compatibility</span></code> for a given factorial basis.</p>
<p>To represent this divisibility condition, we need to stablish the value for <span class="math notranslate nohighlight">\(A\)</span> and how the division
of <span class="math notranslate nohighlight">\(P_{k-A}(n)\)</span> and <span class="math notranslate nohighlight">\(LP_k(n)\)</span> actually happens. Namely, since the degrees of <span class="math notranslate nohighlight">\(P_{k-A}(n)\)</span> and 
<span class="math notranslate nohighlight">\(LP_k(n)\)</span> are fixed, then we can represent:</p>
<div class="math notranslate nohighlight">
\[\frac{LP_k(n)}{P_{k-A}(n)} = \sum_{i=0}^{A+B} \delta_{i}(k) \beta(n)^i.\]</div>
<p>Where <span class="math notranslate nohighlight">\(\delta_i(k)\)</span> are sequences in <span class="math notranslate nohighlight">\(k\)</span> that defines how the division condition changes for each <span class="math notranslate nohighlight">\(k \geq A\)</span>.
Hidden in this notation is the case when the compatibility is in <span class="math notranslate nohighlight">\(t\)</span> sections. It is then clear that the 
sequences <span class="math notranslate nohighlight">\(\delta_{i}(k)\)</span> may be defined in sections too, leading to the same structure as in a compatibility
by sections. Namely, let <span class="math notranslate nohighlight">\(k = mt+r\)</span> for <span class="math notranslate nohighlight">\(m\geq 0\)</span> and <span class="math notranslate nohighlight">\(r\in \{0,\ldots,t-1\}\)</span>:</p>
<div class="math notranslate nohighlight">
\[\frac{LP_{mt+r}}{P_{k-A}(n)} = \sum_{i=0}^{A+B} \delta_{r,i}(m) \beta(n)^i`.\]</div>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">delta</span></code>: a list/tuple or a list/tuple of list/tuples with sequences representing the sequences <span class="math notranslate nohighlight">\(\delta\)</span>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">A</span></code>: integer representing the lower bound for the division. Used to know exactly where the divisibility condition starts.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">base</span></code> (optional): the universe of the sequences in <code class="docutils literal notranslate"><span class="pre">delta</span></code>. Used optionally to enforce this universe on the sequences.
If not given, the universe will be deduced from the arguments in <code class="docutils literal notranslate"><span class="pre">delta</span></code> automatically.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">t</span></code> (optional): number of sections to be used. If not given it is deduced from the input <code class="docutils literal notranslate"><span class="pre">delta</span></code>. Otherwise, we 
enforce that <code class="docutils literal notranslate"><span class="pre">delta</span></code> is a list of at least <code class="docutils literal notranslate"><span class="pre">t</span></code> lists.</p></li>
</ul>
<dl class="py attribute">
<dt class="sig sig-object py" id="pseries_basis.polynomial.factorial.DivisionCondition.lower_bound">
<span class="sig-name descname"><span class="pre">lower_bound</span></span><a class="headerlink" href="#pseries_basis.polynomial.factorial.DivisionCondition.lower_bound" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pseries_basis.polynomial.factorial.DivisionCondition.A">
<span class="sig-name descname"><span class="pre">A</span></span><a class="headerlink" href="#pseries_basis.polynomial.factorial.DivisionCondition.A" title="Permalink to this definition">¶</a></dt>
<dd><p>alias for <code class="docutils literal notranslate"><span class="pre">lower_bound</span></code></p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pseries_basis.polynomial.factorial.DivisionCondition.sections">
<span class="sig-name descname"><span class="pre">sections</span></span><a class="headerlink" href="#pseries_basis.polynomial.factorial.DivisionCondition.sections" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pseries_basis.polynomial.factorial.DivisionCondition.t">
<span class="sig-name descname"><span class="pre">t</span></span><a class="headerlink" href="#pseries_basis.polynomial.factorial.DivisionCondition.t" title="Permalink to this definition">¶</a></dt>
<dd><p>alias for <code class="docutils literal notranslate"><span class="pre">sections</span></code></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pseries_basis.polynomial.factorial.DivisionCondition.coefficient">
<span class="sig-name descname"><span class="pre">coefficient</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">index</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">section</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pseries_basis.polynomial.factorial.DivisionCondition.coefficient" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pseries_basis.polynomial.factorial.DivisionCondition.size">
<span class="sig-name descname"><span class="pre">size</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pseries_basis.polynomial.factorial.DivisionCondition.size" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pseries_basis.polynomial.factorial.DivisionCondition.base">
<span class="sig-name descname"><span class="pre">base</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pseries_basis.polynomial.factorial.DivisionCondition.base" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pseries_basis.polynomial.factorial.DivisionCondition.change_base">
<span class="sig-name descname"><span class="pre">change_base</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">new_base</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pseries_basis.polynomial.factorial.DivisionCondition.change_base" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pseries_basis.polynomial.factorial.DivisionCondition.in_sections">
<span class="sig-name descname"><span class="pre">in_sections</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">new_sections</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pseries_basis.polynomial.factorial.DivisionCondition.in_sections" title="Permalink to this definition">¶</a></dt>
<dd><p>Represent the division condition for a given number of sections (if possible).</p>
<p>Let us assume that for some operator and basis we have the following division condition.</p>
<div class="math notranslate nohighlight">
\[\frac{L P_{mt+r}(n)}{P_{mt+r-A}(n)} = \sum_{i=0}^{A+B} \delta_{r,i}(m)\beta(n)^i.\]</div>
<p>This is a divisibility condition in <span class="math notranslate nohighlight">\(t\)</span> sections. Then, for any <span class="math notranslate nohighlight">\(T\)</span> multiple of <span class="math notranslate nohighlight">\(t\)</span>, we can 
also write a division condition. Namely, let <span class="math notranslate nohighlight">\(k = MT+R\)</span> for <span class="math notranslate nohighlight">\(M \geq 0\)</span>, <span class="math notranslate nohighlight">\(R \in \{0,\ldots, T\}\)</span>.
Then, <span class="math notranslate nohighlight">\(k = (Mq_T + q_R) + r_R\)</span> where <span class="math notranslate nohighlight">\(q_Tt = T\)</span> and <span class="math notranslate nohighlight">\(q_R t + r_R = R\)</span>. Hence,</p>
<div class="math notranslate nohighlight">
\[\frac{L P_{MT+R}(n)}{P_{mt+r-A}(n)} = \frac{L P_{(Mq_T + q_R) + r_R}(n)}{P_{(Mq_T + q_R) + r_R-A}(n)} = 
\sum_{i=0}^{A+B} \delta_{r_R, i}(Mq_T+q_R) \beta(n)^i.\]</div>
<p>Hence, we have that the new <span class="math notranslate nohighlight">\(\tilde{\delta}_{R,i}(M) = \delta_{r_R, i}(Mq_T+q_R)\)</span>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">new_sections</span></code>: number of new sections. It must be a multiple of <code class="docutils literal notranslate"><span class="pre">self.sections</span></code>.</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pseries_basis.polynomial.factorial.DivisionCondition.to_compatibility">
<span class="sig-name descname"><span class="pre">to_compatibility</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">basis</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pseries_basis.polynomial.factorial.DivisionCondition.to_compatibility" title="Permalink to this definition">¶</a></dt>
<dd><p>Method that implements the equivalence of <a class="reference external" href="https://dx.doi.org/10.1016/j.jsc.2022.11.002">doi:10.1016/j.jsc.2022.11.002</a>, Proposition 11.</p>
<p>Let us assume that for some operator and basis we have the following division condition.</p>
<div class="math notranslate nohighlight">
\[\frac{L P_{mt+r}(n)}{P_{mt+r-A}(n)} = \sum_{i=0}^{A+B} \delta_{r,i}(m)\beta(n)^i.\]</div>
<p>Then, we can simply multiply both sides by <span class="math notranslate nohighlight">\(P_{mt+r-A}(n)\)</span>, and check how the different multiplications with <span class="math notranslate nohighlight">\(\beta(n)^i\)</span>
affects the element <span class="math notranslate nohighlight">\(P_{mt+r-A}(n)\)</span>. Let us assume that</p>
<div class="math notranslate nohighlight">
\[\beta(n)^i P_{mt+r}(n) = \sum_{j=0}^i \alpha_{r,j}^{(i)}(m)P_{mt+r+j}(n),\]</div>
<p>(note that <span class="math notranslate nohighlight">\(j \geq 0\)</span> since <span class="math notranslate nohighlight">\(P_k(n)\)</span> is a <span class="math notranslate nohighlight">\(\beta(n)\)</span>-factorial basis). Let <span class="math notranslate nohighlight">\((r - A) = Qt + R\)</span>, where <span class="math notranslate nohighlight">\(R \in \{0,\ldots,t-1\}\)</span>.
Then we have that</p>
<div class="math notranslate nohighlight">
\[\beta(n)^i P_{mt+r-A}(n) = \beta(n)^i P_{(m+Q)t + R}(n) = \sum_{j=0}^i \alpha_{R,j}^{(i)}(m+Q)P_{mt+r-A+j}(n).\]</div>
<p>Hence, putting everything together, we obtain the following identity:</p>
<div class="math notranslate nohighlight">
\[L P_{mt+r}(n) = \sum_{i=0}^{A+B} \delta_{r,i}(m)\beta(n)^i P_{mt+r-A}(n)
              = \sum_{i=0}^{A+B} \delta_{r,i}(m) \sum_{j=0}^i \alpha_{R,j}^{(i)}(m+Q)P_{mt+r-A+j}(n)
              = \sum_{j=0}^{A+B} \sum_{i=j}^{A+B} \delta_{r,i}(m) \alpha_{R,j}^{(i)}(m+Q)P_{mt+r-A+j}(n)
              = \sum_{j=-A}^{B}  \sum_{i=j+A}^{A+B} \delta_{r,i}(m) \alpha_{R,j+A}^{(i)}(m+Q)P_{mt+r+j}(n)
              = \sum_{j=-A}^{B}  \left(\sum_{i=j+A}^{A+B} \delta_{r,i}(m) \alpha_{R,j+A}^{(i)}(m+Q)\right) P_{mt+r+j}(n),\]</div>
<p>Hence we get that the new compatibility coefficients for exactly <span class="math notranslate nohighlight">\(t\)</span> sections (i.e., same sections as the division condition) are the following:</p>
<div class="math notranslate nohighlight">
\[\tilde{\alpha}_{r,i}(m) = \sum_{j=i+A}^{A+B} \delta_{r,j}(m) \alpha_{R,i+A}^{(j)}(m+Q)\]</div>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">basis</span></code>: a <a class="reference internal" href="#pseries_basis.polynomial.factorial.FactorialBasis" title="pseries_basis.polynomial.factorial.FactorialBasis"><code class="xref py py-class docutils literal notranslate"><span class="pre">FactorialBasis</span></code></a> to be used for the compatibility with the _variable_ <span class="math notranslate nohighlight">\(\beta(n)\)</span>.</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pseries_basis.polynomial.factorial.DivisionCondition.from_compatibility">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">from_compatibility</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">compatibility</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">basis</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pseries_basis.polynomial.factorial.DivisionCondition.from_compatibility" title="Permalink to this definition">¶</a></dt>
<dd><p>Method that implements the converse equivalence of <a class="reference external" href="https://dx.doi.org/10.1016/j.jsc.2022.11.002">doi:10.1016/j.jsc.2022.11.002</a>, Proposition 11.</p>
<p>Let us assume now that we have an <span class="math notranslate nohighlight">\((A,B)\)</span>-compatible operator <span class="math notranslate nohighlight">\(L\)</span> in <span class="math notranslate nohighlight">\(t\)</span> sections with a basis <span class="math notranslate nohighlight">\(P_k(n)\)</span>. Then
it follows that</p>
<div class="math notranslate nohighlight">
\[L P_{mt+r}(n) = \sum_{i=-A}^{B} \alpha_{r,i}(m) P_{mt+r+i}(n).\]</div>
<p>By definition of a factorial basis, the polynomials <span class="math notranslate nohighlight">\(P_k(n)\)</span> always divide the polynomials <span class="math notranslate nohighlight">\(P_K(n)\)</span> for every <span class="math notranslate nohighlight">\(K \geq k\)</span>. 
In particular, we can divide the whole identity by <span class="math notranslate nohighlight">\(P_{mt+r-A}(n)\)</span> obtaining the following:</p>
<div class="math notranslate nohighlight">
\[\frac{L P_{mt+r}(n)}{P_{mt+r-A}(n)} = \sum_{i=-A}^{B} \alpha_{r,i}(m) \frac{P_{mt+r+i}(n)}{P_{mt+r-A}(n)}.\]</div>
<p>Clearly, the quotients <span class="math notranslate nohighlight">\(\frac{P_{mt+r+i}(n)}{P_{mt+r-A}(n)}\)</span> are polynomials of degree <span class="math notranslate nohighlight">\(A+i\)</span> in the variable of the 
factorial basis <span class="math notranslate nohighlight">\(\beta(n)\)</span>. Hence, we can see that each <span class="math notranslate nohighlight">\(P_{mt+r+i}(n)\)</span> is a linear combination of <span class="math notranslate nohighlight">\(\beta(n)^i P_{mt+r-A}(n)\)</span>.</p>
<p>Let <span class="math notranslate nohighlight">\((r - A) = Qt + R\)</span>, where <span class="math notranslate nohighlight">\(R \in \{0,\ldots,t-1\}\)</span>. Then we have that, following the compatibility with <span class="math notranslate nohighlight">\(\beta(n)\)</span> (which 
comes from the fact of being a factorial basis):</p>
<div class="math notranslate nohighlight">
\[\beta(n)^i P_{mt+r-A}(n) = \beta(n)^i P_{(m+Q)t + R}(n) = \sum_{j=0}^i \alpha_{R,j}^{(i)}(m+Q)P_{mt+r-A+j}(n).\]</div>
<p>Let us consider the matrix generated by the sequences <span class="math notranslate nohighlight">\(\alpha_{R,j}^{(i)}(m+Q)\)</span> and denote it by <span class="math notranslate nohighlight">\(\Lambda\)</span>. Then</p>
<div class="math notranslate nohighlight">
\[\begin{split}P_{mt+r-A}(n) \begin{pmatrix}1\\\beta(n)\\\beta(n)^2\\\vdots\\\beta(n)^{A+B}\end{pmatrix} = 
\Lambda \begin{pmatrix} P_{mt+r-A}(n) \\ P_{mt+r-A+1}(n) \\ \vdots \\ P_{mt+r+B}(n)\end{pmatrix}\end{split}\]</div>
<p>The matrix <span class="math notranslate nohighlight">\(\Lambda\)</span> is triangular with the diagonal full of 1s. Hence, it is invertible (even in the sequence ring). Multiplying from
the left by this inverse, we get the identity</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{pmatrix} P_{mt+r-A}(n) \\ P_{mt+r-A+1}(n) \\ \vdots \\ P_{mt+r+B}(n)\end{pmatrix} = 
\Lambda^{-1}\begin{pmatrix}1\\\beta(n)\\\beta(n)^2\\\vdots\\\beta(n)^{A+B}\end{pmatrix}P_{mt+r-A}(n).\end{split}\]</div>
<p>Let assume that we obtain something like</p>
<div class="math notranslate nohighlight">
\[P_{mt+r-A+i}(n) = \sum_{j=0}^{i} \lambda_{r,j}^{(i)} \beta(n)^jP_{mt+r-A}(n),\]</div>
<p>Then we can plug this into the first equation, obtaining:</p>
<div class="math notranslate nohighlight">
\[\frac{L P_{mt+r}(n)}{P_{mt+r-A}(n)} = \sum_{i=-A}^{B} \alpha_{r,i}(m) \frac{P_{mt+r+i}(n)}{P_{mt+r-A}(n)} 
                                    = \sum_{i=0}^{A+B} \alpha_{r,i-A}(m) \frac{P_{mt+r-A+i}(n)}{P_{mt+r-A}(n)}
                                    = \sum_{i=0}^{A+B} \alpha_{r,i-A}(m) \left(\sum_{j=0}^{i} \lambda_{r,j}^{(i)} \beta(n)^j\right)
                                    = \sum_{i=0}^{A+B} \sum_{j=0}^{i} \alpha_{r,i-A}(m) \lambda_{r,j}^{(i)} \beta(n)^j
                                    = \sum_{j=0}^{A+B} \left(\sum_{i=j}^{A+B} \alpha_{r,i-A}(m) \lambda_{r,j}^{(i)}\right) \beta(n)^j\]</div>
<p>Hence we obtain that the division coefficients that need to be computed are:</p>
<div class="math notranslate nohighlight">
\[\delta_{r,i}(m) = \sum_{i=j}^{A+B} \alpha_{r,i-A}(m) \lambda_{r,j}^{(i)}\]</div>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">compatibility</span></code>: a <code class="xref py py-class docutils literal notranslate"><span class="pre">Compatibility</span></code> condition for a linear operator.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">basis</span></code>: a <a class="reference internal" href="#pseries_basis.polynomial.factorial.FactorialBasis" title="pseries_basis.polynomial.factorial.FactorialBasis"><code class="xref py py-class docutils literal notranslate"><span class="pre">FactorialBasis</span></code></a> for which the compatibility condition holds.</p></li>
</ul>
<p>OUTPUT:</p>
<p>The <a class="reference internal" href="#pseries_basis.polynomial.factorial.DivisionCondition" title="pseries_basis.polynomial.factorial.DivisionCondition"><code class="xref py py-class docutils literal notranslate"><span class="pre">DivisionCondition</span></code></a> associated to the given <code class="docutils literal notranslate"><span class="pre">basis</span></code> and the <code class="docutils literal notranslate"><span class="pre">compatibility</span></code> described.</p>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pseries_basis.polynomial.factorial.check_division_condition">
<span class="sig-prename descclassname"><span class="pre">pseries_basis.polynomial.factorial.</span></span><span class="sig-name descname"><span class="pre">check_division_condition</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">basis</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">division</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">action</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bound</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">_full</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pseries_basis.polynomial.factorial.check_division_condition" title="Permalink to this definition">¶</a></dt>
<dd><p>Method that checks whether a basis has a particular division condition for a given action.</p>
<p>This method takes a <a class="reference internal" href="#pseries_basis.polynomial.factorial.FactorialBasis" title="pseries_basis.polynomial.factorial.FactorialBasis"><code class="xref py py-class docutils literal notranslate"><span class="pre">FactorialBasis</span></code></a> (i.e., a sequence of sequences), a given
operator compatible with it (or simply the <a class="reference internal" href="#pseries_basis.polynomial.factorial.DivisionCondition" title="pseries_basis.polynomial.factorial.DivisionCondition"><code class="xref py py-class docutils literal notranslate"><span class="pre">DivisionCondition</span></code></a> object representing
such compatibility) and check whether the action that is defined for the operator/division condition
(which is provided by the argument <code class="docutils literal notranslate"><span class="pre">action</span></code>) has precisely this division condition.</p>
<p>More precisely, if an operator <span class="math notranslate nohighlight">\(L\)</span> has a division condition (see <a class="reference internal" href="#pseries_basis.polynomial.factorial.DivisionCondition" title="pseries_basis.polynomial.factorial.DivisionCondition"><code class="xref py py-class docutils literal notranslate"><span class="pre">DivisionCondition</span></code></a>) in <span class="math notranslate nohighlight">\(t\)</span>
sections given by the formula:</p>
<div class="math notranslate nohighlight">
\[\frac{LP_{mt+r}(n)}{P_{mt+r-A}(n)} = \sum_{i=0}^{A+B} \delta_{r,i}(m) \beta(n)^i.\]</div>
<p>then this method checks this identity for the <code class="docutils literal notranslate"><span class="pre">action</span></code> defining <span class="math notranslate nohighlight">\(L\)</span>, and the division condition
defined in <code class="docutils literal notranslate"><span class="pre">division</span></code>. To avoid problems with the division by zero, we will compute this identity
multiplying everything by <span class="math notranslate nohighlight">\(P_{k-A}(n)\)</span>, namely:</p>
<div class="math notranslate nohighlight">
\[LP_{mt+r}(n) = \sum_{i=0}^{A+B} \delta_{r,i}(m) \beta(n)^iP_{mt+r-A}(n).\]</div>
<p>This checking is perform until a given <span class="math notranslate nohighlight">\(m\)</span> and <span class="math notranslate nohighlight">\(n\)</span> bounded by the input <code class="docutils literal notranslate"><span class="pre">bound</span></code>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">basis</span></code>: a <code class="xref py py-class docutils literal notranslate"><span class="pre">PSBasis</span></code> that defines the basis <span class="math notranslate nohighlight">\(P=(P_n)_n\)</span>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">division</span></code>: a division condition. If an operator is given, then division condition
for <code class="docutils literal notranslate"><span class="pre">basis</span></code> is computed (check method <a class="reference internal" href="#pseries_basis.polynomial.factorial.FactorialBasis.compatible_division" title="pseries_basis.polynomial.factorial.FactorialBasis.compatible_division"><code class="xref py py-func docutils literal notranslate"><span class="pre">FactorialBasis.compatible_division()</span></code></a>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">action</span></code>: a callable that actually computes the element <span class="math notranslate nohighlight">\(L P_n\)</span> so it can be compared.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">bound</span></code>: a bound for the limit this equality will be checked. Since <span class="math notranslate nohighlight">\(L P_n\)</span> is a sequence
this bound is used both for checking equality at each level <span class="math notranslate nohighlight">\(n\)</span> and until which level the 
identity is checked.</p></li>
</ul>
<p>OUTPUT:</p>
<p><code class="docutils literal notranslate"><span class="pre">True</span></code> if all the checking provide equality, and <code class="docutils literal notranslate"><span class="pre">False</span></code> otherwise. Be cautious when reading
this output: <code class="docutils literal notranslate"><span class="pre">False</span></code> guarantees that the compatibility is <strong>not</strong> for the action, however, <code class="docutils literal notranslate"><span class="pre">True</span></code>
provides a nice hint the result should be True, but it is not a complete proof.</p>
<p>TODO: add examples</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pseries_basis.polynomial.factorial.ShuffledBasis">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pseries_basis.polynomial.factorial.</span></span><span class="sig-name descname"><span class="pre">ShuffledBasis</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">factors</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cycle</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">_extend_by_zero</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwds</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pseries_basis.polynomial.factorial.ShuffledBasis" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pseries_basis.polynomial.factorial.FactorialBasis" title="pseries_basis.polynomial.factorial.FactorialBasis"><code class="xref py py-class docutils literal notranslate"><span class="pre">pseries_basis.polynomial.factorial.FactorialBasis</span></code></a></p>
<p>Class for a Shuffled Basis.</p>
<p>A sieved basis is a factorial basis built from a finite set
of source basis <span class="math notranslate nohighlight">\(B_i = \left(P_k^{(i)}(n)\right)_k\)</span> for <span class="math notranslate nohighlight">\(i=0,\ldots,F-1\)</span>. This is built 
in <span class="math notranslate nohighlight">\(m\)</span> sections using a <em>deciding cycle</em>:</p>
<div class="math notranslate nohighlight">
\[(\sigma_0,\ldots,\sigma_{m-1})\]</div>
<p>where <span class="math notranslate nohighlight">\(\sigma_i \in \{0,\ldots,F-1\}\)</span>. We can then define the <span class="math notranslate nohighlight">\(n\)</span>-th element
of the basis with the following formula:</p>
<div class="math notranslate nohighlight">
\[Q_k(n) = \prod_{i=0}^F P_{e_i(k)}^{(i)}(n)\]</div>
<p>where the following formula stands:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(k = lm+r\)</span>,</p></li>
<li><p><span class="math notranslate nohighlight">\(S_i = \# \{ j \in \{0,\ldots,m-1\}\ :\ \sigma_j = i\}\)</span>,</p></li>
<li><p><span class="math notranslate nohighlight">\(e_i(k) = S_i l + \#\{j \in \{0,\ldots,r\}\ :\ \sigma_j = i\}\)</span>.</p></li>
</ul>
<p>If we look recursively, we can see that each element is built from the previous
element by increasing one of the factors one degree in the corresponding basis:</p>
<div class="math notranslate nohighlight">
\[Q_k(n) = Q_{k-1}(n)\frac{P_{e_{\sigma_i}(k)}^{(\sigma_i)}(n)}{P_{e_{\sigma_i}(k)-1}^{(\sigma_i)}(n)}\]</div>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">factors</span></code>: the basis that build the sieved basis.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">cycle</span></code>: a tuple of length <span class="math notranslate nohighlight">\(m\)</span> indicating which factor use in each step.</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sage</span><span class="p">:</span> <span class="kn">from</span> <span class="nn">pseries_basis.polynomial.factorial</span> <span class="kn">import</span> <span class="o">*</span>
<span class="n">sage</span><span class="p">:</span> <span class="n">B</span> <span class="o">=</span> <span class="n">BinomialBasis</span><span class="p">;</span> <span class="n">P</span> <span class="o">=</span> <span class="n">PowerBasis</span>
<span class="n">sage</span><span class="p">:</span> <span class="n">B2</span> <span class="o">=</span> <span class="n">ShuffledBasis</span><span class="p">([</span><span class="n">B</span><span class="p">,</span><span class="n">P</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
<span class="o">...</span> <span class="p">[</span><span class="n">ShuffledBasis</span><span class="p">]</span> <span class="n">Compatibility</span> <span class="k">with</span> <span class="n">endomorphism</span> <span class="n">E</span><span class="o">=</span><span class="s1">&#39;E&#39;</span> <span class="n">could</span> <span class="ow">not</span> <span class="n">be</span> <span class="n">extended</span> <span class="p">(</span><span class="ow">not</span> <span class="ow">in</span> <span class="nb">all</span> <span class="n">bases</span><span class="p">)</span>
<span class="n">sage</span><span class="p">:</span> <span class="n">B2</span><span class="p">[:</span><span class="mi">4</span><span class="p">]</span>
<span class="p">[</span><span class="n">Sequence</span> <span class="n">over</span> <span class="p">[</span><span class="n">Rational</span> <span class="n">Field</span><span class="p">]:</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span><span class="o">...</span><span class="p">),</span>
 <span class="n">Sequence</span> <span class="n">over</span> <span class="p">[</span><span class="n">Rational</span> <span class="n">Field</span><span class="p">]:</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span><span class="o">...</span><span class="p">),</span>
 <span class="n">Sequence</span> <span class="n">over</span> <span class="p">[</span><span class="n">Rational</span> <span class="n">Field</span><span class="p">]:</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span><span class="o">...</span><span class="p">),</span>
 <span class="n">Sequence</span> <span class="n">over</span> <span class="p">[</span><span class="n">Rational</span> <span class="n">Field</span><span class="p">]:</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span><span class="o">...</span><span class="p">)]</span>
<span class="n">sage</span><span class="p">:</span> <span class="p">[</span><span class="n">el</span><span class="o">.</span><span class="n">generic</span><span class="p">()</span> <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="n">B2</span><span class="p">[:</span><span class="mi">6</span><span class="p">]]</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="o">^</span><span class="mi">2</span><span class="p">,</span> <span class="n">n</span><span class="o">^</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="o">*</span><span class="n">n</span><span class="o">^</span><span class="mi">4</span> <span class="o">-</span> <span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="o">*</span><span class="n">n</span><span class="o">^</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="mi">6</span><span class="o">*</span><span class="n">n</span><span class="o">^</span><span class="mi">5</span> <span class="o">-</span> <span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="o">*</span><span class="n">n</span><span class="o">^</span><span class="mi">4</span> <span class="o">+</span> <span class="mi">1</span><span class="o">/</span><span class="mi">3</span><span class="o">*</span><span class="n">n</span><span class="o">^</span><span class="mi">3</span><span class="p">]</span>
</pre></div>
</div>
<p>With this system, we can build the same basis changing the order and the values in the cycle:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sage</span><span class="p">:</span> <span class="n">B3</span> <span class="o">=</span> <span class="n">ShuffledBasis</span><span class="p">([</span><span class="n">P</span><span class="p">,</span><span class="n">B</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="o">...</span> <span class="p">[</span><span class="n">ShuffledBasis</span><span class="p">]</span> <span class="n">Compatibility</span> <span class="k">with</span> <span class="n">endomorphism</span> <span class="n">E</span><span class="o">=</span><span class="s1">&#39;Id&#39;</span> <span class="n">could</span> <span class="ow">not</span> <span class="n">be</span> <span class="n">extended</span> <span class="p">(</span><span class="ow">not</span> <span class="ow">in</span> <span class="nb">all</span> <span class="n">bases</span><span class="p">)</span>
<span class="o">...</span> <span class="p">[</span><span class="n">ShuffledBasis</span><span class="p">]</span> <span class="n">Compatibility</span> <span class="k">with</span> <span class="n">derivation</span> <span class="n">D</span><span class="o">=</span><span class="s1">&#39;Dn&#39;</span> <span class="n">could</span> <span class="ow">not</span> <span class="n">be</span> <span class="n">extended</span> <span class="p">(</span><span class="ow">not</span> <span class="ow">in</span> <span class="nb">all</span> <span class="n">bases</span><span class="p">)</span>
<span class="n">sage</span><span class="p">:</span> <span class="n">B3</span><span class="o">.</span><span class="n">almost_equals</span><span class="p">(</span><span class="n">B2</span><span class="p">,</span> <span class="mi">30</span><span class="p">)</span> <span class="c1"># checking equality for 30 elements </span>
<span class="kc">True</span>
</pre></div>
</div>
<p>The length of the cycle is the number of associated sections:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sage</span><span class="p">:</span> <span class="n">B2</span><span class="o">.</span><span class="n">nsections</span>
<span class="mi">4</span>
<span class="n">sage</span><span class="p">:</span> <span class="n">ShuffledBasis</span><span class="p">([</span><span class="n">B</span><span class="p">,</span><span class="n">B</span><span class="p">,</span><span class="n">P</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">nsections</span>
<span class="o">...</span> <span class="p">[</span><span class="n">ShuffledBasis</span><span class="p">]</span> <span class="n">Compatibility</span> <span class="k">with</span> <span class="n">endomorphism</span> <span class="n">E</span><span class="o">=</span><span class="s1">&#39;E&#39;</span> <span class="n">could</span> <span class="ow">not</span> <span class="n">be</span> <span class="n">extended</span> <span class="p">(</span><span class="ow">not</span> <span class="ow">in</span> <span class="nb">all</span> <span class="n">bases</span><span class="p">)</span>
<span class="mi">6</span>
</pre></div>
</div>
<p>This basis can be use to deduce some nice recurrences for the Apery’s <span class="math notranslate nohighlight">\(\zeta(2)\)</span> sequence:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sage</span><span class="p">:</span> <span class="c1">#TODO b1 = FallingBasis(1,0,1); b2 = FallingBasis(1,1,-1); n = b1.n()</span>
<span class="n">sage</span><span class="p">:</span> <span class="c1">#TODO B = ShuffledBasis([b1,b2],[0,1]).scalar(1/factorial(n))</span>
</pre></div>
</div>
<p>This basis <code class="docutils literal notranslate"><span class="pre">B</span></code> contains the elements</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{matrix}
\binom{n + k}{2k}\ \text{if }k\equiv 0\ (mod\ 2)\\
\binom{n + k}{2k+1}\ \text{if }k\equiv 1\ (mod\ 2)
\end{matrix}\end{split}\]</div>
<p>We first extend the compatibility with <span class="math notranslate nohighlight">\(E: x\mapsto x+1\)</span> by guessing and then we compute the sieved basis
with the binomial basis with the cycle <span class="math notranslate nohighlight">\((1,0,1)\)</span>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sage</span><span class="p">:</span> <span class="c1">#TODO B.set_endomorphism(&#39;E&#39;, guess_compatibility_E(B, sections=2))</span>
<span class="n">sage</span><span class="p">:</span> <span class="c1">#TODO B2 = ShuffledBasis([BinomialBasis(), B], [1,0,1])</span>
</pre></div>
</div>
<p>Now the basis <code class="docutils literal notranslate"><span class="pre">B2</span></code> is formed in 3 sections by the following elements:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{matrix}
    \binom{n}{k}\binom{n+k}{2k}\ \text{if }k\equiv 0\ (mod\ 3)\\
    \binom{n}{k}\binom{n+k}{2k+1}\ \text{if }k\equiv 1\ (mod\ 3)\\
    \binom{n}{k+1}\binom{n+k}{2k+1}\ \text{if }k\equiv 2\ (mod\ 3)
\end{matrix}\end{split}\]</div>
<p>We can check that <span class="math notranslate nohighlight">\(B2\)</span> is compatible with the multiplication by <span class="math notranslate nohighlight">\(x\)</span> and with 
the endomorphism <span class="math notranslate nohighlight">\(E\)</span>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sage</span><span class="p">:</span> <span class="c1">#TODO a,b,m,alpha = B2.compatibility(&#39;x&#39;)</span>
<span class="n">sage</span><span class="p">:</span> <span class="c1">#TODO Matrix([[alpha(i,j,B2.n()) for j in range(-a,b+1)] for i in range(m)]) ## output: [      n 2*n + 1], [      n   n + 1], [ -n - 1 2*n + 2]</span>
<span class="n">sage</span><span class="p">:</span> <span class="c1">#TODO B2.recurrence(&#39;x&#39;) ## output: [        n         0 (2*n)*Sni], [(2*n + 1)         n         0], [        0   (n + 1)  (-n - 1)]</span>
<span class="n">sage</span><span class="p">:</span> <span class="c1">#TODO a,b,m,alpha = B2.compatibility(&#39;E&#39;)</span>
<span class="n">sage</span><span class="p">:</span> <span class="c1">#TODO Matrix([[alpha(i,j,B2.n()) for j in range(-a,b+1)] for i in range(m)]) ## output: [                      1           (4*n - 3/2)/n                     3/2                       1], [    (n - 1/2)/(n + 1/2)         1/2*n/(n + 1/2) (3/2*n + 1/2)/(n + 1/2)                       1], [                      0                       1       (3*n + 2)/(n + 1)                       1]</span>
<span class="n">sage</span><span class="p">:</span> <span class="c1">#TODO B2.recurrence(&#39;E&#39;) ## output: [                    Sn + 1        (3*n + 1)/(2*n + 1)                          1], [    (8*n + 5)/(2*n + 2)*Sn (2*n + 1)/(2*n + 3)*Sn + 1          (3*n + 2)/(n + 1)], [                    3/2*Sn       (n + 1)/(2*n + 3)*Sn                          1]</span>
</pre></div>
</div>
<p>Now consider the following difference operator:</p>
<div class="math notranslate nohighlight">
\[L = (n+2)^2 E^2 - (11n^2+33n+25)E - (n+1)^3\]</div>
<p>This operator <span class="math notranslate nohighlight">\(L\)</span> is compatible with the basis <code class="docutils literal notranslate"><span class="pre">B2</span></code>. We can get then
the associated recurrence matrix. Taking the first column and the GCRD
of its elements, we can see that if a sequence <span class="math notranslate nohighlight">\(y(n)\)</span>
that can be written in the form <span class="math notranslate nohighlight">\(y(n) = \sum_{k\geq 0}c_k\binom{n}{k}\binom{n+k}{2k}\)</span> satisfies
that</p>
<div class="math notranslate nohighlight">
\[(k+1)^2c_{k+1} - 2(2k+1)c_k = 0.\]</div>
<p>Doing that with the code:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sage</span><span class="p">:</span> <span class="c1">#TODO from ore_algebra import OreAlgebra</span>
<span class="n">sage</span><span class="p">:</span> <span class="c1">#TODO R.&lt;x&gt; = QQ[]; OE.&lt;E&gt; = OreAlgebra(R, (&#39;E&#39;, lambda p : p(x=x+1), lambda p : 0))   </span>
<span class="n">sage</span><span class="p">:</span> <span class="c1">#TODO L = (x+2)^2*E^2 - (11*x^2 + 33*x+25)*E - (x+1)^2 </span>
<span class="n">sage</span><span class="p">:</span> <span class="c1">#TODO M = B2.recurrence(L)</span>
<span class="n">sage</span><span class="p">:</span> <span class="c1">#TODO column = [B2.remove_Sni(M.coefficient((j,0))) for j in range(M.nrows())]</span>
<span class="n">sage</span><span class="p">:</span> <span class="c1">#TODO column[0].gcrd(*column[1:]) ## output: (n + 1)*Sn - 4*n - 2</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="pseries_basis.polynomial.factorial.ShuffledBasis.counts">
<span class="sig-name descname"><span class="pre">counts</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pseries_basis.polynomial.factorial.ShuffledBasis.counts" title="Permalink to this definition">¶</a></dt>
<dd><p>Counting of appearances of each factor during a cycle</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pseries_basis.polynomial.factorial.ShuffledBasis.extra">
<span class="sig-name descname"><span class="pre">extra</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">factor</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">remainder</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pseries_basis.polynomial.factorial.ShuffledBasis.extra" title="Permalink to this definition">¶</a></dt>
<dd><p>Counting function that computes how many times a factor has appear until the given remainder</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pseries_basis.polynomial.factorial.ShuffledBasis.indices">
<span class="sig-name descname"><span class="pre">indices</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pseries_basis.polynomial.factorial.ShuffledBasis.indices" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the indices of each factor in the given element.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pseries_basis.polynomial.factorial.ShuffledBasis.division_decomposition">
<span class="sig-name descname"><span class="pre">division_decomposition</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">indices</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pseries_basis.polynomial.factorial.ShuffledBasis.division_decomposition" title="Permalink to this definition">¶</a></dt>
<dd><p>Any combination of elements of the factors can be written as a maximal element
in the sieved basis times a polynomial. This method computes this decomposition.</p>
<p>It returns the tuple of indices, the index and the polynomial that remains</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pseries_basis.polynomial.factorial.ShuffledBasis.factors">
<span class="sig-name descname"><span class="pre">factors</span></span><a class="headerlink" href="#pseries_basis.polynomial.factorial.ShuffledBasis.factors" title="Permalink to this definition">¶</a></dt>
<dd><p>Property to get the factors of the <a class="reference internal" href="#pseries_basis.polynomial.factorial.ShuffledBasis" title="pseries_basis.polynomial.factorial.ShuffledBasis"><code class="xref py py-class docutils literal notranslate"><span class="pre">ShuffledBasis</span></code></a></p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pseries_basis.polynomial.factorial.ShuffledBasis.cycle">
<span class="sig-name descname"><span class="pre">cycle</span></span><a class="headerlink" href="#pseries_basis.polynomial.factorial.ShuffledBasis.cycle" title="Permalink to this definition">¶</a></dt>
<dd><p>Property to get the deciding cycle of the <a class="reference internal" href="#pseries_basis.polynomial.factorial.ShuffledBasis" title="pseries_basis.polynomial.factorial.ShuffledBasis"><code class="xref py py-class docutils literal notranslate"><span class="pre">ShuffledBasis</span></code></a></p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pseries_basis.polynomial.factorial.ShuffledBasis.nfactors">
<span class="sig-name descname"><span class="pre">nfactors</span></span><a class="headerlink" href="#pseries_basis.polynomial.factorial.ShuffledBasis.nfactors" title="Permalink to this definition">¶</a></dt>
<dd><p>Method to get the number of factors of the sieved basis.</p>
<p>This method returns the number of factors which compose
this <a class="reference internal" href="#pseries_basis.polynomial.factorial.ShuffledBasis" title="pseries_basis.polynomial.factorial.ShuffledBasis"><code class="xref py py-class docutils literal notranslate"><span class="pre">ShuffledBasis</span></code></a>.</p>
<p>OUTPUT:</p>
<p>Number of factors of this <a class="reference internal" href="#pseries_basis.polynomial.factorial.ShuffledBasis" title="pseries_basis.polynomial.factorial.ShuffledBasis"><code class="xref py py-class docutils literal notranslate"><span class="pre">ShuffledBasis</span></code></a>.</p>
<p>TODO: add examples</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pseries_basis.polynomial.factorial.ShuffledBasis.F">
<span class="sig-name descname"><span class="pre">F</span></span><a class="headerlink" href="#pseries_basis.polynomial.factorial.ShuffledBasis.F" title="Permalink to this definition">¶</a></dt>
<dd><p>alias for the number of factors</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pseries_basis.polynomial.factorial.ShuffledBasis.nsections">
<span class="sig-name descname"><span class="pre">nsections</span></span><a class="headerlink" href="#pseries_basis.polynomial.factorial.ShuffledBasis.nsections" title="Permalink to this definition">¶</a></dt>
<dd><p>Method to get the number of sections of the sieved basis.</p>
<p>This method returns the number of elements in the deciding cycle which 
is the number of sections in which the <a class="reference internal" href="#pseries_basis.polynomial.factorial.ShuffledBasis" title="pseries_basis.polynomial.factorial.ShuffledBasis"><code class="xref py py-class docutils literal notranslate"><span class="pre">ShuffledBasis</span></code></a> is divided.</p>
<p>OUTPUT:</p>
<p>Number of sections of this <a class="reference internal" href="#pseries_basis.polynomial.factorial.ShuffledBasis" title="pseries_basis.polynomial.factorial.ShuffledBasis"><code class="xref py py-class docutils literal notranslate"><span class="pre">ShuffledBasis</span></code></a>.</p>
<p>TODO: add examples</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pseries_basis.polynomial.factorial.ShuffledBasis.m">
<span class="sig-name descname"><span class="pre">m</span></span><a class="headerlink" href="#pseries_basis.polynomial.factorial.ShuffledBasis.m" title="Permalink to this definition">¶</a></dt>
<dd><p>alias for the number of sections in the cycle</p>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pseries_basis.polynomial.factorial.ProductBasis">
<span class="sig-prename descclassname"><span class="pre">pseries_basis.polynomial.factorial.</span></span><span class="sig-name descname"><span class="pre">ProductBasis</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">factors</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pseries_basis.polynomial.factorial.ProductBasis" title="Permalink to this definition">¶</a></dt>
<dd><p>Factory for creating a special type of <a class="reference internal" href="#pseries_basis.polynomial.factorial.ShuffledBasis" title="pseries_basis.polynomial.factorial.ShuffledBasis"><code class="xref py py-class docutils literal notranslate"><span class="pre">ShuffledBasis</span></code></a>: Product Basis.</p>
<p>Namely, the <span class="math notranslate nohighlight">\(k=lm+j\)</span> element of the product of <span class="math notranslate nohighlight">\(m\)</span> basis, is the product of</p>
<div class="math notranslate nohighlight">
\[Q_k(n) = \prod_{i=1}^{j}P_{l+1}^{(j)}(n)\prod_{i=j+1}^{m}P_{l}^{(j)}(n).\]</div>
<p>See the paper <a class="reference external" href="https://dx.doi.org/10.1016/j.jsc.2022.11.002">doi:10.1016/j.jsc.2022.11.002</a> for further information.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">factors</span></code>: list of <a class="reference internal" href="#pseries_basis.polynomial.factorial.FactorialBasis" title="pseries_basis.polynomial.factorial.FactorialBasis"><code class="xref py py-class docutils literal notranslate"><span class="pre">FactorialBasis</span></code></a>.</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sage</span><span class="p">:</span> <span class="kn">from</span> <span class="nn">pseries_basis</span> <span class="kn">import</span> <span class="o">*</span>
<span class="n">sage</span><span class="p">:</span> <span class="n">B1</span> <span class="o">=</span> <span class="n">BinomialBasis</span><span class="p">;</span> <span class="n">B2</span> <span class="o">=</span> <span class="n">PowerBasis</span><span class="p">;</span> <span class="n">B3</span> <span class="o">=</span> <span class="n">FallingBasis</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="n">sage</span><span class="p">:</span> <span class="c1">#TODO ProductBasis(B1,B2).factors == (B1, B2) ## output: True</span>
<span class="n">sage</span><span class="p">:</span> <span class="c1">#TODO ProductBasis(B1,B2).nfactors() ## output: 2</span>
<span class="n">sage</span><span class="p">:</span> <span class="c1">#TODO ProductBasis([B1,B3,B2]).factors == (B1,B3,B2) ## output: True</span>
<span class="n">sage</span><span class="p">:</span> <span class="c1">#TODO ProductBasis([B1,B3,B2]).nfactors() ## output: 3</span>
</pre></div>
</div>
<p>This method is a simplification of a call to <a class="reference internal" href="#pseries_basis.polynomial.factorial.ShuffledBasis" title="pseries_basis.polynomial.factorial.ShuffledBasis"><code class="xref py py-class docutils literal notranslate"><span class="pre">ShuffledBasis</span></code></a>. The following example
illustrates how this can be used to understand better the recurrence for the Apery’s <span class="math notranslate nohighlight">\(\zeta(3)\)</span>-recurrence:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sage</span><span class="p">:</span> <span class="c1">#TODO b1 = FallingBasis(1,0,1); b2 = FallingBasis(1,1,-1); n = b1.n()</span>
<span class="n">sage</span><span class="p">:</span> <span class="c1">#TODO B = ProductBasis([b1,b2]).scalar(1/factorial(n))</span>
</pre></div>
</div>
<p>This basis <code class="docutils literal notranslate"><span class="pre">B</span></code> contains the elements</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{matrix}
\binom{n + k}{2k}\ \text{if }k\equiv 0\ (mod\ 2)\\
\binom{n + k}{2k+1}\ \text{if }k\equiv 1\ (mod\ 2)
\end{matrix}\end{split}\]</div>
<p>We first extend the compatibility with <span class="math notranslate nohighlight">\(E: n\mapsto n+1\)</span> by guessing and then we compute the product basis
with itself:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sage</span><span class="p">:</span> <span class="c1">#TODO B.set_endomorphism(&#39;E&#39;, guess_compatibility_E(B, sections=2))</span>
<span class="n">sage</span><span class="p">:</span> <span class="c1">#TODO B2 = ProductBasis([B,B])</span>
</pre></div>
</div>
<p>Now the basis <code class="docutils literal notranslate"><span class="pre">B2</span></code> is formed in 4 sections by the following elements:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{matrix}
    \binom{n+k}{2k}^2\ \text{if }k\equiv 0\ (mod\ 4)\\
    \binom{n+k}{2k}\binom{n+k}{2k+1}\ \text{if }k\equiv 1\ (mod\ 4)\\
    \binom{n+k}{2k+1}^2\ \text{if }k\equiv 2\ (mod\ 4)\\
    \binom{n+k+1}{2k+2}\binom{n+k}{2k+1}\ \text{if }k\equiv 3\ (mod\ 4)
\end{matrix}\end{split}\]</div>
<p>We can check that <code class="docutils literal notranslate"><span class="pre">B2</span></code> is compatible with the multiplication by <span class="math notranslate nohighlight">\(n\)</span> and with 
the endomorphism <span class="math notranslate nohighlight">\(E\)</span>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sage</span><span class="p">:</span> <span class="c1">#TODO a,b,m,alpha = B2.compatibility(&#39;x&#39;)</span>
<span class="n">sage</span><span class="p">:</span> <span class="c1">#TODO Matrix([[alpha(i,j,B2.n()) for j in range(-a,b+1)] for i in range(m)]) ## output: [      n 2*n + 1], [      n 2*n + 1], [ -n - 1 2*n + 2], [ -n - 1 2*n + 2]</span>
<span class="n">sage</span><span class="p">:</span> <span class="c1">#TODO B2.recurrence(&#39;x&#39;) ## output: [        n         0         0 (2*n)*Sni], [(2*n + 1)         n         0         0], [        0 (2*n + 1)  (-n - 1)         0], [        0         0 (2*n + 2)  (-n - 1)]</span>
</pre></div>
</div>
<p>Now consider the following difference operator:</p>
<div class="math notranslate nohighlight">
\[L = (n+2)^3 E^2 - (2*n + 3)(17*n^2+51*n+39)E + (n+1)^3\]</div>
<p>This operator <span class="math notranslate nohighlight">\(L\)</span> is compatible with the basis <code class="docutils literal notranslate"><span class="pre">B2</span></code>. We can get then
the associated recurrence matrix. Taking the first column and the GCRD
of its elements, we can see that if a sequence <span class="math notranslate nohighlight">\(y(n)\)</span>
that can be written in the form <span class="math notranslate nohighlight">\(y(n) = \sum_{k\geq 0}c_k\binom{n+k}{2k}^2\)</span> satisfies
that</p>
<div class="math notranslate nohighlight">
\[(k+1)^2c_{k+1} - 4(2k+1)^2c_k = 0.\]</div>
<p>Doing that with the code:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sage</span><span class="p">:</span> <span class="c1">#TODO from ore_algebra import OreAlgebra</span>
<span class="n">sage</span><span class="p">:</span> <span class="c1">#TODO R.&lt;x&gt; = QQ[]; OE.&lt;E&gt; = OreAlgebra(R, (&#39;E&#39;, lambda p : p(x=x+1), lambda p : 0))   </span>
<span class="n">sage</span><span class="p">:</span> <span class="c1">#TODO L = (x+2)^3 *E^2 - (2*x+3)*(17*x^2+51*x+39)*E+(x+1)^3</span>
<span class="n">sage</span><span class="p">:</span> <span class="c1">#TODO M = B2.recurrence(L)</span>
<span class="n">sage</span><span class="p">:</span> <span class="c1">#TODO column = [B2.remove_Sni(M.coefficient((j,0))) for j in range(4)]</span>
<span class="n">sage</span><span class="p">:</span> <span class="c1">#TODO column[0].gcrd(*column[1:]) ## output: (n^2 + 2*n + 1)*Sn - 16*n^2 - 16*n - 4</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pseries_basis.polynomial.factorial.DefiniteSumSolutions">
<span class="sig-prename descclassname"><span class="pre">pseries_basis.polynomial.factorial.</span></span><span class="sig-name descname"><span class="pre">DefiniteSumSolutions</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">operator</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">input</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pseries_basis.polynomial.factorial.DefiniteSumSolutions" title="Permalink to this definition">¶</a></dt>
<dd><p>Petkovšek’s algorithm for transforming operators into recurrence equations.</p>
<p>This method is the complete execution for the algorithm <strong>DefiniteSumSolutions</strong> described in
<a class="reference external" href="https://dx.doi.org/10.1016/j.jsc.2022.11.002">doi:10.1016/j.jsc.2022.11.002</a>. This methods takes an operator <span class="math notranslate nohighlight">\(L\)</span> and convert the problem
of being solution <span class="math notranslate nohighlight">\(L \cdot y(n) = 0\)</span> to a recurrence equation assuming some hypergeometric
terms in the expansion.</p>
<p>The operator must be a difference operator of <span class="math notranslate nohighlight">\(\mathbb{Q}[x]&lt;E&gt;\)</span> where <span class="math notranslate nohighlight">\(E: n \mapsto n+1\)</span>.</p>
<p>This function does not check the nature of the generator, so using this algorithm with different 
types of operators may lead to some inconsistent results.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">operator</span></code>: difference operator to be transformed.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">input</span></code>: the coefficients of the binomial coefficients we assume appear in the expansion
of the solutions. This input can be given with the following formats:
- <code class="docutils literal notranslate"><span class="pre">a_1,a_2,...,a_m,b_1,b_2,...,b_m</span></code>: an unrolled list of <span class="math notranslate nohighlight">\(2m\)</span> elements.
- <code class="docutils literal notranslate"><span class="pre">[a_1,a_2,...,a_m,b_1,b_2,...,b_m]</span></code>: a compress list of <span class="math notranslate nohighlight">\(2m\)</span> elements.
- <code class="docutils literal notranslate"><span class="pre">[a_1,...,a_m],[b_1,...,b_m]</span></code>: two lists of <span class="math notranslate nohighlight">\(m\)</span> elements.</p></li>
</ul>
<p>OUTPUT:</p>
<p>An operator <span class="math notranslate nohighlight">\(\tilde{L}\)</span> such that if a sequence <span class="math notranslate nohighlight">\((c_k)_k\)</span> satisfies <span class="math notranslate nohighlight">\(L \cdot (c_k)_k = 0\)</span> then 
the sequence</p>
<div class="math notranslate nohighlight">
\[y(n) = \sum_{k \geq 0}c_k\prod{i=1}^m \binom{a_in+b_i}{k}\]</div>
<p>satisfies <span class="math notranslate nohighlight">\(L \cdot y(n) = 0\)</span>.</p>
<p>EXAMPLES:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sage</span><span class="p">:</span> <span class="kn">from</span> <span class="nn">pseries_basis</span> <span class="kn">import</span> <span class="o">*</span>
<span class="n">sage</span><span class="p">:</span> <span class="kn">from</span> <span class="nn">ore_algebra</span> <span class="kn">import</span> <span class="n">OreAlgebra</span>
<span class="n">sage</span><span class="p">:</span> <span class="n">R</span><span class="o">.&lt;</span><span class="n">n</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">QQ</span><span class="p">[];</span> <span class="n">OE</span><span class="o">.&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">OreAlgebra</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;E&#39;</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">p</span> <span class="p">:</span> <span class="n">p</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span> <span class="k">lambda</span> <span class="n">p</span> <span class="p">:</span> <span class="mi">0</span><span class="p">))</span>
<span class="n">sage</span><span class="p">:</span> <span class="c1">#TODO DefiniteSumSolutions((n+1)*E - 2*(2*n+1), 1,1,0,0) ## output: Sk - 1</span>
<span class="n">sage</span><span class="p">:</span> <span class="n">example_2</span> <span class="o">=</span> <span class="mi">4</span><span class="o">*</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">n</span><span class="o">+</span><span class="mi">3</span><span class="p">)</span><span class="o">^</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="n">n</span><span class="o">+</span><span class="mi">3</span><span class="p">)</span><span class="o">*</span><span class="n">E</span><span class="o">^</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="n">n</span><span class="o">+</span><span class="mi">5</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">20</span><span class="o">*</span><span class="n">n</span><span class="o">^</span><span class="mi">2</span><span class="o">+</span><span class="mi">50</span><span class="o">*</span><span class="n">n</span><span class="o">+</span><span class="mi">27</span><span class="p">)</span><span class="o">*</span><span class="n">E</span> <span class="o">+</span> <span class="mi">9</span><span class="o">*</span><span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="n">n</span><span class="o">+</span><span class="mi">7</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">^</span><span class="mi">2</span>
<span class="n">sage</span><span class="p">:</span> <span class="c1">#TODO DefiniteSumSolutions(example_2, 1,1,0,0) ## output: (k + 1/2)*Sk - 1/4*k - 1/4</span>
</pre></div>
</div>
</dd></dl>

</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <div>
    <h4>Previous topic</h4>
    <p class="topless"><a href="../polynomial.html"
                          title="previous chapter">Polynomial Bases: basic bases for formal power series</a></p>
  </div>
  <div>
    <h4>Next topic</h4>
    <p class="topless"><a href="orthogonal.html"
                          title="next chapter">Generalized Binomial Bases</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../../_sources/pseries_basis/polynomial/factorial.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="orthogonal.html" title="Generalized Binomial Bases"
             >next</a> |</li>
        <li class="right" >
          <a href="../polynomial.html" title="Polynomial Bases: basic bases for formal power series"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">pseries_basis</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../polynomial.html" >Polynomial Bases: basic bases for formal power series</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Factorial Basis: simplest Polynomial basis</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2022.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 4.4.0.
    </div>
  </body>
</html>