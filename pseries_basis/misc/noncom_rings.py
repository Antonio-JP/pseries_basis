r'''
    Module with the implementation of a non-commutative free algebra that can be rewritten always in
    a particular way (i.e., there is a canonical form for all its elements).

    This implementation is based on the class :class:`~sage.algebras.free_algebra.FreeAlgebra`. Mathematically,
    a Free Algebra can be seen as a `\mathbb{F}`-vector space generated by a monoid `G` and where we define the 
    multiplication (as a ring) by extending by association the following rule:

    .. MATH::

        (a \cdot g) (b \cdot h) = (ab) \cdot (gh)

    where `a,b \in \mathbb{F}` and `g,h \in G`. 

    If the elements of the monoid `G` are considered as operators over some space, then the Free Algebra can be seen
    as the ring of operators where the multiplication is the composition. These type of algebras are usually non-commutative.

    This module provides a class :class:`OperatorAlgebra` which is based in the implementation on Sage of 
    :class:`~sage.algebras.free_algebra.FreeAlgebra`.
'''
from functools import reduce
from typing import Any, Collection, Tuple
from sage.all import prod, ZZ
from sage.algebras.free_algebra import FreeAlgebra_generic
from sage.algebras.free_algebra_element import FreeAlgebraElement
from sage.misc.cachefunc import cached_method #pylint: disable=no-name-in-module
from sage.structure.factory import UniqueFactory #pylint: disable=no-name-in-module

class OperatorAlgebraFactory(UniqueFactory):
    def create_key(self, *args, **kwds):
        # allowing the args input to not be unrolled
        if len(args) == 1 and isinstance(args[0], (list, tuple)):
            args = args[0]

        if len(args) == 0:
            base = kwds["base"]; names = kwds["names"]; relations = kwds.get("relations", tuple([]))
        if len(args) == 1:
            if "base" in kwds:
                raise TypeError("Duplicated value for the base ring")
            base = args[0]; names = kwds["names"]; relations = kwds.get("relations", tuple([]))
        if len(args) == 2:
            if "base" in kwds:
                raise TypeError("Duplicated value for the base ring")
            if "names" in kwds:
                raise TypeError("Duplicated value for variable names")
            base = args[0]; names = args[1]; relations = kwds.get("relations", tuple([]))
        if len(args) >= 3:
            if "base" in kwds:
                raise TypeError("Duplicated value for the base ring")
            if "names" in kwds:
                raise TypeError("Duplicated value for variable names")
            if "relations" in kwds:
                raise TypeError("Duplicated value for the relations")
            base = args[0]; names = args[1]; relations = args[2]

        ## Processing the relations
        if any((not isinstance(relation, (tuple, list)) or len(relation) != 3) for relation in relations):
            raise ValueError("The relations must be 3-tuples/lists")
        relations = [tuple([str(el) for el in relation]) for relation in relations]

        return (base, tuple(names), tuple(relations))

    def create_object(self, _, key):
        base, names, relations = key
        return OperatorAlgebra_generic(base, names, relations)
OperatorAlgebra = OperatorAlgebraFactory("pseries_basis.misc.noncom_rings.OperatorAlgebra")

class OperatorAlgebra_element(FreeAlgebraElement):
    def __init__(self, A, x):
        super().__init__(A, x)

        self.__canonical = None

    def is_canonical(self):
        gens = [str(g) for g in self.parent().gens()]
        def _is_canonical_monomial(monomial):
            l = [str(el) for el in monomial.to_list()]
            return all(gens.index(l[i]) <= gens.index(l[i+1]) for i in range(len(l)-1))

        return all(_is_canonical_monomial(mon) for mon in self.monomial_coefficients().keys())

    def canonical(self):
        if self.__canonical is None:
            mc_dict = self.monomial_coefficients()
            self.__canonical = sum(mc_dict[m]*self.parent().canonical_monomial(m) for m in mc_dict)
        return self.__canonical

    def degrees(self):
        r'''
            Method to get the degrees (if possible) w.r.t. all variables.
        '''
        if (not self.parent().is_complete_commutation()) or (not self.is_canonical()):
            raise ValueError("The degrees can only be computed from a canonical form")

        gnames = self.parent().variable_names()
        def _degrees_canonical_monomial(monomial):
            monoid_list = [str(el) for el in monomial.to_list()]
            return tuple([monoid_list.count(g) for g in gnames])
        degrees_by_monomial = [_degrees_canonical_monomial(m) for m in self.monomial_coefficients()]
        return tuple([max(degrees_by_monomial[i][j] for i in range(len(degrees_by_monomial))) for j in range(len(gnames))])

    def degree(self, var):
        r'''
            Method to get the degree of a polynomial (if possible) w.r.t. a variable.

            INPUT:

            * ``var``: either the index, the element in ``self.parent()`` or the name of the variable to be
              checked.
        '''
        gnames = self.parent().variable_names()
        if var in ZZ:
            var = gnames[var]
        elif var in self.parent():
            var = str(var)
        if isinstance(var, str) and (not var in gnames):
            raise ValueError(f"The name of the variable ({var}) must be valid for the ring {self.parent()}")

        ind = gnames.index(var)
        return self.degrees()[ind]
            
    def variables(self):
        return tuple([v for v in self.parent().gens() if self.degree(v) > 0])

    def constant_coefficient(self):
        r'''Method to return the constant coefficient of an operator'''
        mon_dict = self.monomial_coefficients()
        base = self.parent().base()
        monoid = self.parent().monoid()
        return mon_dict.get(monoid.one(), base.zero())

    def coefficient(self, monomial):
        if (not self.parent().is_complete_commutation()):
            raise ValueError("The coefficient can only be computed from a canonical form")

        canonical = self.canonical()
        gens = self.parent().gens()
        gnames = self.parent().variable_names()

        if isinstance(monomial, dict): # the variables in dict must appear with this degree
            if any(not el in gnames for el in gnames):
                raise TypeError(f"Monomial {monomial} not valid for {self.parent()}")
            result = self.parent().zero()
            for mon, coeff in self.monomial_coefficients().items():
                mon_list = [str(el) for el in mon.to_list()]
                mon_degrees = [mon_list.count(g) for g in gnames]

                # checking if it is a valid monomial
                if all(monomial[g] == mon_degrees[gnames.index(g)] for g in monomial):
                    result += coeff * prod(gens[i]**mon_degrees[i] for i in range(len(gnames)) if not gnames[i] in monomial)
            return result
        # otherwise, we cast the input to a list of degrees
        if monomial in self.parent() or monomial in self.parent().base():
            monomial = self.parent()(monomial)
            if len(monomial) > 1:
                raise TypeError(f"Monomial {monomial} not valid for {self.parent()}")
            monomial = monomial.degrees()
        elif monomial in self.parent().monoid():
            monomial = monomial.to_list()
            monomial = [monomial.count(g) for g in gnames]
        elif (not isinstance(monomial, (list,tuple))) or (len(monomial) != len(gnames)) or any((not el in ZZ) or el < 0 for el in monomial):
            raise TypeError(f"Monomial {monomial} not valid for {self.parent()}")
        
        if all(deg == 0 for deg in monomial):
            return canonical.constant_coefficient()

        result = self.parent().zero()
        for (mon, coeff) in canonical.monomial_coefficients().items():
            mon_list = [str(el) for el in mon.to_list()]
            mon_degrees = [mon_list.count(g) for g in gnames]
            if all(monomial[i] == mon_degrees[i] for i in range(len(gnames)) if monomial[i] > 0):
                result += coeff * prod([gens[i]**mon_degrees[i] for i in range(len(gnames)) if monomial[i] == 0])

        return result

    def __call__(self, **values):
        gens = [str(g) for g in self.parent().gens()]
        values = {k : self.parent(v) for (k,v) in values.items() if k in gens}
        def _evaluate_monomial(monomial, values):
            return prod([values[str(el)] if str(el) in values else self.parent()(el) for el in monomial.to_list()], self.parent().one())

        return sum([coeff*_evaluate_monomial(mon, values) for (mon, coeff) in self.monomial_coefficients().items()], self.parent().zero())

    def apply(self, element, substitutions):
        gens = self.parent().variable_names()
        if isinstance(substitutions, (list, tuple)):
            substitutions = {gens[i] : substitutions[i] for i in range(len(gens))}
        elif isinstance(substitutions, dict):
            if any(not g in substitutions for g in gens):
                raise ValueError("We need a method for all generators")

        result = self.parent().base().zero()
        for (mon, coeff) in self.monomial_coefficients().items():
            monoid_list = [substitutions[str(el)] for el in mon.to_list()]; monoid_list.reverse()
            evaluated = reduce(lambda p, q : q(p), monoid_list, element)
            result = result + coeff * evaluated
        return result

class OperatorAlgebra_generic(FreeAlgebra_generic):
    r'''
        Class for an algebra of non-commutative operators. 

        This class extends the implementation of :class:`~sage.algebras.free_algebra.FreeAlgebra` allowing to 
        define more relations than in the method :func:`g_algebra`.

        The order of the names is important to decide the order for computing canonical forms of the elements.
        When enough relations are given, then all the element in the free algebra will have a canonical representation.

        INPUT:

        * ``base``: the base field `\mathbb{F}` where all the coefficients will belong.
        * ``names``: sorted tuple of names for the generators of the Monoid that defines the free-algebra. We will consider
          that the appearance order is the increasing relation among the generators.
        * ``relations``: a tuple of 3-tuples `(a,b,c)` with the strings that define the relation `ab = c`.
    '''
    Element = OperatorAlgebra_element

    def __init__(self, base, names, relations: Tuple[Tuple[str,str,str]]):
        super().__init__(base, len(names), names)
        self.__relations = {}
        for relation in relations:
            g1,g2,val = [self(el) for el in relation]
            if g1*g2 in self.__relations:
                raise ValueError(f"The relation between {g1} and {g2} was already defined")
            gens = self.gens()
            if gens.index(g1) <= gens.index(g2):
                raise ValueError(f"Provided an unnecessary relation ({g1}--{g2})")
            if not val.is_canonical():
                raise ValueError(f"The new value for the relations must be in canonical form")
            self.__relations[g1*g2] = val 
            
    def _element_constructor_(self, x):
        if isinstance(x, str): # expanding the behavior for strings
            from sage.misc.sage_eval import sage_eval
            G = self.gens()
            d = {str(v): G[i] for i,v in enumerate(self.variable_names())}
            C = self.base()
            while not 1 in C.gens(): 
                for g in C.gens():
                    if not g in d:
                        d[str(g)] = g
                C = C.base()

            return self(sage_eval(x, locals=d))
        return super()._element_constructor_(x)

    def add_relations(self, relations : Collection[Tuple[Any,Any,Any]]):
        # collecting the relations from ``self``
        all_relations = []
        for k,v in self.relations.items():
            all_relations.append(tuple([str(el) for el in k.trailing_support().to_list()] + [str(v)]))
        for relation in relations:
            all_relations.append(relation)

        return OperatorAlgebra(self.base(), self.variable_names(), all_relations)

    def change_ring(self, new_ring):
        # collecting the relations from ``self``
        all_relations = []
        for k,v in self.relations.items():
            all_relations.append(tuple([str(el) for el in k.trailing_support().to_list()] + [str(v)]))

        return OperatorAlgebra(new_ring, self.variable_names(), all_relations)

    @property
    def relations(self):
        return self.__relations
        
    def is_complete_commutation(self):
        r'''
            Method checking whether the Operator algebra has all the commutation rules.
        '''
        gens = self.gens()
        for i in range(len(gens)):
            for j in range(i+1, len(gens)):
                if not gens[j]*gens[i] in self.relations:
                    return False
        return True

    @cached_method
    def canonical_monomial(self, monomial):
        r'''
            Method that computes the canonical equivalent for a monomial.
        '''
        gens = self.gens()
        leq = lambda p, q : gens.index(p) <= gens.index(q)
        monoid_list = monomial.to_list()
        # first, we remove inverses
        i = 0
        while i < len(monoid_list)-1:
            v1,v2 = monoid_list[i], monoid_list[i+1]
            if self.are_inverses(self(v1), self(v2)):
                monoid_list.pop(i); monoid_list.pop(i)
            else:
                i += 1
        # now we reduce other commutations
        for i in range(len(monoid_list)-1):
            if not leq(monoid_list[i], monoid_list[i+1]):
                v1, v2 = monoid_list[i], monoid_list[i+1]
                try:
                    new_val = self.relations[self(v1*v2)]
                except KeyError:
                    raise KeyError(f"The relation between {v1} and {v2} is not defined. Impossible to get canonical form")
                monoid_list.pop(i)
                monoid_list[i] = new_val
                return prod([self(el) for el in monoid_list]).canonical()
        return prod([self(el) for el in monoid_list])

    def are_inverses(self, g1, g2):
        return self.relations.get(g1*g2, self.relations.get(g2*g1, 0)) == 1

    def __repr__(self) -> str:
        return f"{'Operator algebra' if self.is_complete_commutation() else 'Non-commutative ring'} on {self.ngens()} generators {self.gens()} over [{self.base()}] with commutation rules:\n  " + "\n  ".join(f"{k} -> {v}" for (k,v) in self.relations.items()) 
        


