r'''
    Module with the implementation of a non-commutative free algebra that can be rewritten always in
    a particular way (i.e., there is a cannonical form for all its elements).

    This implementation is based on the class :class:`~sage.algebras.free_algebra.FreeAlgebra`. Mathematically,
    a Free Algebra can be seen as a `\mathbb{F}`-vector space generated by a monoid `G` and where we define the 
    multiplication (as a ring) by extending by association the following rule:

    .. MATH::

        (a \cdot g) (b \cdot h) = (ab) \cdot (gh)

    where `a,b \in \mathbb{F}` and `g,h \in G`. 

    If the elements of the monoid `G` are considered as operators over some space, then the Free Algebra can be seen
    as the ring of operators where the multiplication is the composition. These type of algebras are usually non-commutative.

    This module provides a class :class:`OperatorAlgebra` which is based in the implementation on Sage of 
    :class:`~sage.algebras.free_algebra.FreeAlgebra`.
'''
from functools import reduce
from typing import Any, Collection, Tuple
from sage.all import prod
from sage.algebras.free_algebra import FreeAlgebra_generic
from sage.algebras.free_algebra_element import FreeAlgebraElement
from sage.misc.cachefunc import cached_method
from sage.structure.factory import UniqueFactory #pylint: disable=no-name-in-module

class OperatorAlgebraFactory(UniqueFactory):
    def create_key(self, *args, **kwds):
        # allowing the args input to not be unrolled
        if len(args) == 1 and isinstance(args[0], (list, tuple)):
            args = args[0]

        if len(args) == 0:
            base = kwds["base"]; names = kwds["names"]; relations = kwds.get("relations", tuple([]))
        if len(args) == 1:
            if "base" in kwds:
                raise TypeError("Duplicated value for the base ring")
            base = args[0]; names = kwds["names"]; relations = kwds.get("relations", tuple([]))
        if len(args) == 2:
            if "base" in kwds:
                raise TypeError("Duplicated value for the base ring")
            if "names" in kwds:
                raise TypeError("Duplicated value for variable names")
            base = args[0]; names = args[1]; relations = kwds.get("relations", tuple([]))
        if len(args) >= 3:
            if "base" in kwds:
                raise TypeError("Duplicated value for the base ring")
            if "names" in kwds:
                raise TypeError("Duplicated value for variable names")
            if "relations" in kwds:
                raise TypeError("Duplicated value for the relations")
            base = args[0]; names = args[1]; relations = args[2]

        ## Processing the relations
        if any((not isinstance(relation, (tuple, list)) or len(relation) != 3) for relation in relations):
            raise ValueError("The relations must be 3-tuples/lists")
        relations = [tuple([str(el) for el in relation]) for relation in relations]

        return (base, tuple(names), tuple(relations))

    def create_object(self, _, key):
        base, names, relations = key
        return OperatorAlgebra_generic(base, names, relations)
OperatorAlgebra = OperatorAlgebraFactory("pseries_basis.misc.noncom_rings.OperatorAlgebra")

class OperatorAlgebra_element(FreeAlgebraElement):
    def is_cannonical(self):
        gens = [str(g) for g in self.parent().gens()]
        def _is_cannonical_monomial(monomial):
            l = [str(el) for el in monomial.to_list()]
            return all(gens.index(l[i]) < gens.index(l[i+1]) for i in range(len(l)-1))

        return all(_is_cannonical_monomial(mon) for mon in self.monomial_coefficients().keys())

    def cannonical(self):
        mc_dict = self.monomial_coefficients()
        return sum(mc_dict[m]*self.parent().cannonical_monomial(m) for m in mc_dict)

    def __call__(self, **values):
        gens = [str(g) for g in self.parent().gens()]
        values = {k : self.parent(v) for (k,v) in values.items() if k in gens}
        def _evaluate_monomial(monomial, values):
            return prod([values[str(el)] if str(el) in values else self.parent()(el) for el in monomial.to_list()])

        return sum([coeff*_evaluate_monomial(mon, values) for (mon, coeff) in self.monomial_coefficients().items()])

    def apply(self, element, subtitutions):
        gens = self.parent().variable_names()
        if isinstance(subtitutions, (list, tuple)):
            subtitutions = {gens[i] : subtitutions[i] for i in range(len(gens))}
        elif isinstance(subtitutions, dict):
            if any(not g in subtitutions for g in gens):
                raise ValueError("We need a method for all generators")

        result = self.parent().base().zero()
        for (mon, coeff) in self.monomial_coefficients().items():
            monoid_list = [subtitutions[str(el)] for el in mon.to_list()]; monoid_list.reverse()
            evaluated = reduce(lambda p, q : q(p), monoid_list, element)
            result = result + coeff * evaluated
        return result

class OperatorAlgebra_generic(FreeAlgebra_generic):
    r'''
        Class for an algebra of non-commutative operators. 

        This class extends the implementation of :class:`~sage.algebras.free_algebra.FreeAlgebra` allowing to 
        define more relations than in the method :func:`g_algebra`.

        The order of the names is important to decide the order for computing cannonical forms of the elements.
        When enough relations are given, then all the element in the free algebra will have a cannonical representation.

        INPUT:

        * ``base``: the base field `\mathbb{F}` where all the coefficients will belong.
        * ``names``: sorted tuple of names for the generators of the Monoid that defines the free-algebra. We will consider
          that the appearance order is the increaing relation among the generators.
        * ``relations``: a tuple of 3-tuples `(a,b,c)` with the strings that define the relation `ab = c`.
    '''
    Element = OperatorAlgebra_element

    def __init__(self, base, names, relations: Tuple[Tuple[str,str,str]]):
        super().__init__(base, len(names), names)
        self.__relations = {}
        for relation in relations:
            g1,g2,val = [self(el) for el in relation]
            if g1*g2 in self.__relations:
                raise ValueError(f"The relation between {g1} and {g2} was already defined")
            gens = self.gens()
            if gens.index(g1) <= gens.index(g2):
                raise ValueError(f"Provided an unnecessary relation ({g1}--{g2})")
            if not val.is_cannonical():
                raise ValueError(f"The new value for the relations must be in cannonical form")
            self.__relations[g1*g2] = val 
            
    def _element_constructor_(self, x):
        if isinstance(x, str): # expanding the behavior for strings
            from sage.misc.sage_eval import sage_eval
            G = self.gens()
            d = {str(v): G[i] for i,v in enumerate(self.variable_names())}
            C = self.base()
            while not 1 in C.gens(): 
                for g in C.gens():
                    if not g in d:
                        d[str(g)] = g
                C = C.base()

            return self(sage_eval(x, locals=d))
        return super()._element_constructor_(x)

    def add_relations(self, relations : Collection[Tuple[Any,Any,Any]]):
        # collecting the relations from ``self``
        all_relations = []
        for k,v in self.relations:
            all_relations.append(tuple([str(el) for el in k.trailing_support().to_list()] + [str(v)]))
        for relation in relations:
            all_relations.append(relation)

        return OperatorAlgebra(self.base(), self.variable_names(), relations)

    @property
    def relations(self):
        return self.__relations
        
    @cached_method
    def cannonical_monomial(self, monomial):
        r'''
            Method that computes the cannonical equivalent for a monomial.
        '''
        gens = self.gens()
        leq = lambda p, q : gens.index(p) <= gens.index(q)
        monoid_list = monomial.to_list()
        # first, we remove inverses
        i = 0
        while i < len(monoid_list)-1:
            v1,v2 = monoid_list[i], monoid_list[i+1]
            if self.are_inverses(self(v1), self(v2)):
                monoid_list.pop(i); monoid_list.pop(i)
            else:
                i += 1
        # now we reduce other commutations
        for i in range(len(monoid_list)-1):
            if not leq(monoid_list[i], monoid_list[i+1]):
                v1, v2 = monoid_list[i], monoid_list[i+1]
                try:
                    new_val = self.relations[self(v1*v2)]
                except KeyError:
                    raise KeyError(f"The relation between {v1} and {v2} is not defined. Impossible to get cannonical form")
                monoid_list.pop(i)
                monoid_list[i] = new_val
                return prod([self(el) for el in monoid_list]).cannonical()
        return prod([self(el) for el in monoid_list])

    def are_inverses(self, g1, g2):
        return self.relations.get(g1*g2, self.relations.get(g2*g1, 0)) == 1

    


